<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>slack_bolt API documentation</title>
<meta name="description" content="A Python framework to build Slack apps in a flash with the latest platform features.Read the [getting started …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>slack_bolt</code></h1>
</header>
<section id="section-intro">
<p>A Python framework to build Slack apps in a flash with the latest platform features.Read the <a href="https://slack.dev/bolt-python/tutorial/getting-started">getting started guide</a> and look at our <a href="https://github.com/slackapi/bolt-python/tree/main/examples">code examples</a> to learn how to build apps using Bolt.</p>
<ul>
<li>Website: <a href="https://slack.dev/bolt-python/">https://slack.dev/bolt-python/</a></li>
<li>GitHub repository: <a href="https://github.com/slackapi/bolt-python">https://github.com/slackapi/bolt-python</a></li>
<li>The class representing a Bolt app: <code><a title="slack_bolt.app.app" href="app/app.html">slack_bolt.app.app</a></code></li>
</ul>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="slack_bolt.adapter" href="adapter/index.html">slack_bolt.adapter</a></code></dt>
<dd>
<div class="desc"><p>Adapter modules for running Bolt apps along with Web frameworks or Socket Mode.</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.app" href="app/index.html">slack_bolt.app</a></code></dt>
<dd>
<div class="desc"><p>Application interface in Bolt …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.async_app" href="async_app.html">slack_bolt.async_app</a></code></dt>
<dd>
<div class="desc"><p>Module for creating asyncio based apps …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.authorization" href="authorization/index.html">slack_bolt.authorization</a></code></dt>
<dd>
<div class="desc"><p>Authorization is the process of determining which Slack credentials should be available
while processing an incoming Slack event …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.context" href="context/index.html">slack_bolt.context</a></code></dt>
<dd>
<div class="desc"><p>All listeners have access to a context dictionary, which can be used to enrich events with additional information.
Bolt automatically attaches …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.error" href="error/index.html">slack_bolt.error</a></code></dt>
<dd>
<div class="desc"><p>Bolt specific error types.</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.kwargs_injection" href="kwargs_injection/index.html">slack_bolt.kwargs_injection</a></code></dt>
<dd>
<div class="desc"><p>For middleware/listener arguments, Bolt does flexible data injection in accordance with their names …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.lazy_listener" href="lazy_listener/index.html">slack_bolt.lazy_listener</a></code></dt>
<dd>
<div class="desc"><p>Lazy listener runner is a beta feature for the apps running on Function-as-a-Service platforms …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.listener" href="listener/index.html">slack_bolt.listener</a></code></dt>
<dd>
<div class="desc"><p>Listeners process an incoming request from Slack if the request's type or data structure matches
the predefined conditions of the listener. Typically, …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.listener_matcher" href="listener_matcher/index.html">slack_bolt.listener_matcher</a></code></dt>
<dd>
<div class="desc"><p>A listener matcher is a simplified version of listener middleware.
A listener matcher function returns bool value instead of <code>next()</code> method …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.logger" href="logger/index.html">slack_bolt.logger</a></code></dt>
<dd>
<div class="desc"><p>Bolt for Python relies on the standard <code>logging</code> module.</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.middleware" href="middleware/index.html">slack_bolt.middleware</a></code></dt>
<dd>
<div class="desc"><p>A middleware processes request data and calls <code>next()</code> method
if the execution chain should continue running the following middleware …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.oauth" href="oauth/index.html">slack_bolt.oauth</a></code></dt>
<dd>
<div class="desc"><p>Slack OAuth flow support for building an app that is installable in any workspaces …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.request" href="request/index.html">slack_bolt.request</a></code></dt>
<dd>
<div class="desc"><p>Incoming request from Slack through either HTTP request or Socket Mode connection …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.response" href="response/index.html">slack_bolt.response</a></code></dt>
<dd>
<div class="desc"><p>This interface represents Bolt's synchronous response to Slack …</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.util" href="util/index.html">slack_bolt.util</a></code></dt>
<dd>
<div class="desc"><p>Internal utilities for the Bolt framework.</p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.version" href="version.html">slack_bolt.version</a></code></dt>
<dd>
<div class="desc"><p>Check the latest version at <a href="https://pypi.org/project/slack-bolt/">https://pypi.org/project/slack-bolt/</a></p></div>
</dd>
<dt><code class="name"><a title="slack_bolt.workflows" href="workflows/index.html">slack_bolt.workflows</a></code></dt>
<dd>
<div class="desc"><p>Steps from apps enables developers to build their own steps …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_bolt.Ack"><code class="flex name class">
<span>class <span class="ident">Ack</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ack:
    response: Optional[BoltResponse]

    def __init__(self):
        self.response: Optional[BoltResponse] = None

    def __call__(
        self,
        text: Union[str, dict] = &#34;&#34;,  # text: str or whole_response: dict
        blocks: Optional[Sequence[Union[dict, Block]]] = None,
        attachments: Optional[Sequence[Union[dict, Attachment]]] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        response_type: Optional[str] = None,  # in_channel / ephemeral
        # block_suggestion / dialog_suggestion
        options: Optional[Sequence[Union[dict, Option]]] = None,
        option_groups: Optional[Sequence[Union[dict, OptionGroup]]] = None,
        # view_submission
        response_action: Optional[str] = None,  # errors / update / push / clear
        errors: Optional[Dict[str, str]] = None,
        view: Optional[Union[dict, View]] = None,
    ) -&gt; BoltResponse:
        return _set_response(
            self,
            text_or_whole_response=text,
            blocks=blocks,
            attachments=attachments,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            response_type=response_type,
            options=options,
            option_groups=option_groups,
            response_action=response_action,
            errors=errors,
            view=view,
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Ack.response"><code class="name">var <span class="ident">response</span> : <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>*,<br>logger: logging.Logger | None = None,<br>name: str | None = None,<br>process_before_response: bool = False,<br>raise_error_for_unhandled_request: bool = False,<br>signing_secret: str | None = None,<br>token: str | None = None,<br>token_verification_enabled: bool = True,<br>client: slack_sdk.web.client.WebClient | None = None,<br>before_authorize: <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a> | Callable[..., Any] | None = None,<br>authorize: Callable[..., <a title="slack_bolt.authorization.authorize_result.AuthorizeResult" href="authorization/authorize_result.html#slack_bolt.authorization.authorize_result.AuthorizeResult">AuthorizeResult</a>] | None = None,<br>user_facing_authorize_error_message: str | None = None,<br>installation_store: slack_sdk.oauth.installation_store.installation_store.InstallationStore | None = None,<br>installation_store_bot_only: bool | None = None,<br>request_verification_enabled: bool = True,<br>ignoring_self_events_enabled: bool = True,<br>ignoring_self_assistant_message_events_enabled: bool = True,<br>ssl_check_enabled: bool = True,<br>url_verification_enabled: bool = True,<br>attaching_function_token_enabled: bool = True,<br>oauth_settings: <a title="slack_bolt.oauth.oauth_settings.OAuthSettings" href="oauth/oauth_settings.html#slack_bolt.oauth.oauth_settings.OAuthSettings">OAuthSettings</a> | None = None,<br>oauth_flow: <a title="slack_bolt.oauth.oauth_flow.OAuthFlow" href="oauth/oauth_flow.html#slack_bolt.oauth.oauth_flow.OAuthFlow">OAuthFlow</a> | None = None,<br>verification_token: str | None = None,<br>listener_executor: concurrent.futures._base.Executor | None = None,<br>assistant_thread_context_store: <a title="slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore" href="context/assistant/thread_context_store/store.html#slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore">AssistantThreadContextStore</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App:
    def __init__(
        self,
        *,
        logger: Optional[logging.Logger] = None,
        # Used in logger
        name: Optional[str] = None,
        # Set True when you run this app on a FaaS platform
        process_before_response: bool = False,
        # Set True if you want to handle an unhandled request as an exception
        raise_error_for_unhandled_request: bool = False,
        # Basic Information &gt; Credentials &gt; Signing Secret
        signing_secret: Optional[str] = None,
        # for single-workspace apps
        token: Optional[str] = None,
        token_verification_enabled: bool = True,
        client: Optional[WebClient] = None,
        # for multi-workspace apps
        before_authorize: Optional[Union[Middleware, Callable[..., Any]]] = None,
        authorize: Optional[Callable[..., AuthorizeResult]] = None,
        user_facing_authorize_error_message: Optional[str] = None,
        installation_store: Optional[InstallationStore] = None,
        # for either only bot scope usage or v1.0.x compatibility
        installation_store_bot_only: Optional[bool] = None,
        # for customizing the built-in middleware
        request_verification_enabled: bool = True,
        ignoring_self_events_enabled: bool = True,
        ignoring_self_assistant_message_events_enabled: bool = True,
        ssl_check_enabled: bool = True,
        url_verification_enabled: bool = True,
        attaching_function_token_enabled: bool = True,
        # for the OAuth flow
        oauth_settings: Optional[OAuthSettings] = None,
        oauth_flow: Optional[OAuthFlow] = None,
        # No need to set (the value is used only in response to ssl_check requests)
        verification_token: Optional[str] = None,
        # Set this one only when you want to customize the executor
        listener_executor: Optional[Executor] = None,
        # for AI Agents &amp; Assistants
        assistant_thread_context_store: Optional[AssistantThreadContextStore] = None,
    ):
        &#34;&#34;&#34;Bolt App that provides functionalities to register middleware/listeners.

            import os
            from slack_bolt import App

            # Initializes your app with your bot token and signing secret
            app = App(
                token=os.environ.get(&#34;SLACK_BOT_TOKEN&#34;),
                signing_secret=os.environ.get(&#34;SLACK_SIGNING_SECRET&#34;)
            )

            # Listens to incoming messages that contain &#34;hello&#34;
            @app.message(&#34;hello&#34;)
            def message_hello(message, say):
                # say() sends a message to the channel where the event was triggered
                say(f&#34;Hey there &lt;@{message[&#39;user&#39;]}&gt;!&#34;)

            # Start your app
            if __name__ == &#34;__main__&#34;:
                app.start(port=int(os.environ.get(&#34;PORT&#34;, 3000)))

        Refer to https://slack.dev/bolt-python/tutorial/getting-started for details.

        If you would like to build an OAuth app for enabling the app to run with multiple workspaces,
        refer to https://slack.dev/bolt-python/concepts#authenticating-oauth to learn how to configure the app.

        Args:
            logger: The custom logger that can be used in this app.
            name: The application name that will be used in logging. If absent, the source file name will be used.
            process_before_response: True if this app runs on Function as a Service. (Default: False)
            raise_error_for_unhandled_request: True if you want to raise exceptions for unhandled requests
                and use @app.error listeners instead of
                the built-in handler, which pints warning logs and returns 404 to Slack (Default: False)
            signing_secret: The Signing Secret value used for verifying requests from Slack.
            token: The bot/user access token required only for single-workspace app.
            token_verification_enabled: Verifies the validity of the given token if True.
            client: The singleton `slack_sdk.WebClient` instance for this app.
            before_authorize: A global middleware that can be executed right before authorize function
            authorize: The function to authorize an incoming request from Slack
                by checking if there is a team/user in the installation data.
            user_facing_authorize_error_message: The user-facing error message to display
                when the app is installed but the installation is not managed by this app&#39;s installation store
            installation_store: The module offering save/find operations of installation data
            installation_store_bot_only: Use `InstallationStore#find_bot()` if True (Default: False)
            request_verification_enabled: False if you would like to disable the built-in middleware (Default: True).
                `RequestVerification` is a built-in middleware that verifies the signature in HTTP Mode requests.
                Make sure if it&#39;s safe enough when you turn a built-in middleware off.
                We strongly recommend using RequestVerification for better security.
                If you have a proxy that verifies request signature in front of the Bolt app,
                it&#39;s totally fine to disable RequestVerification to avoid duplication of work.
                Don&#39;t turn it off just for easiness of development.
            ignoring_self_events_enabled: False if you would like to disable the built-in middleware (Default: True).
                `IgnoringSelfEvents` is a built-in middleware that enables Bolt apps to easily skip the events
                generated by this app&#39;s bot user (this is useful for avoiding code error causing an infinite loop).
            ignoring_self_assistant_message_events_enabled: False if you would like to disable the built-in middleware.
                `IgnoringSelfEvents` for this app&#39;s bot user message events within an assistant thread
                This is useful for avoiding code error causing an infinite loop; Default: True
            url_verification_enabled: False if you would like to disable the built-in middleware (Default: True).
                `UrlVerification` is a built-in middleware that handles url_verification requests
                that verify the endpoint for Events API in HTTP Mode requests.
            attaching_function_token_enabled: False if you would like to disable the built-in middleware (Default: True).
                `AttachingFunctionToken` is a built-in middleware that injects the just-in-time workflow-execution tokens
                when your app receives `function_executed` or interactivity events scoped to a custom step.
            ssl_check_enabled: bool = False if you would like to disable the built-in middleware (Default: True).
                `SslCheck` is a built-in middleware that handles ssl_check requests from Slack.
            oauth_settings: The settings related to Slack app installation flow (OAuth flow)
            oauth_flow: Instantiated `slack_bolt.oauth.OAuthFlow`. This is always prioritized over oauth_settings.
            verification_token: Deprecated verification mechanism. This can be used only for ssl_check requests.
            listener_executor: Custom executor to run background tasks. If absent, the default `ThreadPoolExecutor` will
                be used.
            assistant_thread_context_store: Custom AssistantThreadContext store (Default: the built-in implementation,
                which uses a parent message&#39;s metadata to store the latest context)
        &#34;&#34;&#34;
        if signing_secret is None:
            signing_secret = os.environ.get(&#34;SLACK_SIGNING_SECRET&#34;, &#34;&#34;)
        token = token or os.environ.get(&#34;SLACK_BOT_TOKEN&#34;)

        self._name: str = name or inspect.stack()[1].filename.split(os.path.sep)[-1]
        self._signing_secret: str = signing_secret

        self._verification_token: Optional[str] = verification_token or os.environ.get(&#34;SLACK_VERIFICATION_TOKEN&#34;, None)
        # If a logger is explicitly passed when initializing, the logger works as the base logger.
        # The base logger&#39;s logging settings will be propagated to all the loggers created by bolt-python.
        self._base_logger = logger
        # The framework logger is supposed to be used for the internal logging.
        # Also, it&#39;s accessible via `app.logger` as the app&#39;s singleton logger.
        self._framework_logger = logger or get_bolt_logger(App)
        self._raise_error_for_unhandled_request = raise_error_for_unhandled_request

        self._token: Optional[str] = token

        if client is not None:
            if not isinstance(client, WebClient):
                raise BoltError(error_client_invalid_type())
            self._client = client
            self._token = client.token
            if token is not None:
                self._framework_logger.warning(warning_client_prioritized_and_token_skipped())
        else:
            self._client = create_web_client(
                # NOTE: the token here can be None
                token=token,
                logger=self._framework_logger,
            )

        # --------------------------------------
        # Authorize &amp; OAuthFlow initialization
        # --------------------------------------

        self._before_authorize: Optional[Middleware] = None
        if before_authorize is not None:
            if callable(before_authorize):
                self._before_authorize = CustomMiddleware(
                    app_name=self._name,
                    func=before_authorize,
                    base_logger=self._framework_logger,
                )
            elif isinstance(before_authorize, Middleware):
                self._before_authorize = before_authorize

        self._authorize: Optional[Authorize] = None
        if authorize is not None:
            if isinstance(authorize, Authorize):
                # As long as an advanced developer understands what they&#39;re doing,
                # bolt-python should not prevent customizing authorize middleware
                self._authorize = authorize
            else:
                if oauth_settings is not None or oauth_flow is not None:
                    # If the given authorize is a simple function,
                    # it does not work along with installation_store.
                    raise BoltError(error_authorize_conflicts())
                self._authorize = CallableAuthorize(logger=self._framework_logger, func=authorize)

        self._installation_store: Optional[InstallationStore] = installation_store
        if self._installation_store is not None and self._authorize is None:
            settings = oauth_flow.settings if oauth_flow is not None else oauth_settings
            self._authorize = InstallationStoreAuthorize(
                installation_store=self._installation_store,
                client_id=settings.client_id if settings is not None else None,
                client_secret=settings.client_secret if settings is not None else None,
                logger=self._framework_logger,
                bot_only=installation_store_bot_only or False,
                client=self._client,  # for proxy use cases etc.
                user_token_resolution=(settings.user_token_resolution if settings is not None else &#34;authed_user&#34;),
            )

        self._oauth_flow: Optional[OAuthFlow] = None

        if (
            oauth_settings is None
            and os.environ.get(&#34;SLACK_CLIENT_ID&#34;) is not None
            and os.environ.get(&#34;SLACK_CLIENT_SECRET&#34;) is not None
        ):
            # initialize with the default settings
            oauth_settings = OAuthSettings()

            if oauth_flow is None and installation_store is None:
                # show info-level log for avoiding confusions
                self._framework_logger.info(info_default_oauth_settings_loaded())

        if oauth_flow is not None:
            self._oauth_flow = oauth_flow
            installation_store = select_consistent_installation_store(
                client_id=self._oauth_flow.client_id,
                app_store=self._installation_store,
                oauth_flow_store=self._oauth_flow.settings.installation_store,
                logger=self._framework_logger,
            )
            self._installation_store = installation_store
            if installation_store is not None:
                self._oauth_flow.settings.installation_store = installation_store

            if self._oauth_flow._client is None:
                self._oauth_flow._client = self._client
            if self._authorize is None:
                self._authorize = self._oauth_flow.settings.authorize
        elif oauth_settings is not None:
            installation_store = select_consistent_installation_store(
                client_id=oauth_settings.client_id,
                app_store=self._installation_store,
                oauth_flow_store=oauth_settings.installation_store,
                logger=self._framework_logger,
            )
            self._installation_store = installation_store
            if installation_store is not None:
                oauth_settings.installation_store = installation_store
            self._oauth_flow = OAuthFlow(client=self.client, logger=self.logger, settings=oauth_settings)
            if self._authorize is None:
                self._authorize = self._oauth_flow.settings.authorize
            self._authorize.token_rotation_expiration_minutes = oauth_settings.token_rotation_expiration_minutes  # type: ignore[attr-defined] # noqa: E501

        if (self._installation_store is not None or self._authorize is not None) and self._token is not None:
            self._token = None
            self._framework_logger.warning(warning_token_skipped())

        # after setting bot_only here, __init__ cannot replace authorize function
        if installation_store_bot_only is not None and self._oauth_flow is not None:
            app_bot_only = installation_store_bot_only or False
            oauth_flow_bot_only = self._oauth_flow.settings.installation_store_bot_only
            if app_bot_only != oauth_flow_bot_only:
                self.logger.warning(warning_bot_only_conflicts())
                self._oauth_flow.settings.installation_store_bot_only = app_bot_only
                self._authorize.bot_only = app_bot_only  # type: ignore[union-attr]

        self._tokens_revocation_listeners: Optional[TokenRevocationListeners] = None
        if self._installation_store is not None:
            self._tokens_revocation_listeners = TokenRevocationListeners(self._installation_store)

        # --------------------------------------
        # Middleware Initialization
        # --------------------------------------

        self._middleware_list: List[Middleware] = []
        self._listeners: List[Listener] = []

        if listener_executor is None:
            listener_executor = ThreadPoolExecutor(max_workers=5)

        self._assistant_thread_context_store = assistant_thread_context_store

        self._process_before_response = process_before_response
        self._listener_runner = ThreadListenerRunner(
            logger=self._framework_logger,
            process_before_response=process_before_response,
            listener_error_handler=DefaultListenerErrorHandler(logger=self._framework_logger),
            listener_start_handler=DefaultListenerStartHandler(logger=self._framework_logger),
            listener_completion_handler=DefaultListenerCompletionHandler(logger=self._framework_logger),
            listener_executor=listener_executor,
            lazy_listener_runner=ThreadLazyListenerRunner(
                logger=self._framework_logger,
                executor=listener_executor,
            ),
        )
        self._middleware_error_handler: MiddlewareErrorHandler = DefaultMiddlewareErrorHandler(
            logger=self._framework_logger,
        )

        self._init_middleware_list_done = False
        self._init_middleware_list(
            token_verification_enabled=token_verification_enabled,
            request_verification_enabled=request_verification_enabled,
            ignoring_self_events_enabled=ignoring_self_events_enabled,
            ignoring_self_assistant_message_events_enabled=ignoring_self_assistant_message_events_enabled,
            ssl_check_enabled=ssl_check_enabled,
            url_verification_enabled=url_verification_enabled,
            attaching_function_token_enabled=attaching_function_token_enabled,
            user_facing_authorize_error_message=user_facing_authorize_error_message,
        )

    def _init_middleware_list(
        self,
        token_verification_enabled: bool = True,
        request_verification_enabled: bool = True,
        ignoring_self_events_enabled: bool = True,
        ignoring_self_assistant_message_events_enabled: bool = True,
        ssl_check_enabled: bool = True,
        url_verification_enabled: bool = True,
        attaching_function_token_enabled: bool = True,
        user_facing_authorize_error_message: Optional[str] = None,
    ):
        if self._init_middleware_list_done:
            return
        if ssl_check_enabled is True:
            self._middleware_list.append(
                SslCheck(
                    verification_token=self._verification_token,
                    base_logger=self._base_logger,
                )
            )
        if request_verification_enabled is True:
            self._middleware_list.append(RequestVerification(self._signing_secret, base_logger=self._base_logger))

        if self._before_authorize is not None:
            self._middleware_list.append(self._before_authorize)

        # As authorize is required for making a Bolt app function, we don&#39;t offer the flag to disable this
        if self._oauth_flow is None:
            if self._token is not None:
                try:
                    auth_test_result = None
                    if token_verification_enabled:
                        # This API call is for eagerly validating the token
                        auth_test_result = self._client.auth_test(token=self._token)
                    self._middleware_list.append(
                        SingleTeamAuthorization(
                            auth_test_result=auth_test_result,
                            base_logger=self._base_logger,
                            user_facing_authorize_error_message=user_facing_authorize_error_message,
                        )
                    )
                except SlackApiError as err:
                    raise BoltError(error_auth_test_failure(err.response))
            elif self._authorize is not None:
                self._middleware_list.append(
                    MultiTeamsAuthorization(
                        authorize=self._authorize,
                        base_logger=self._base_logger,
                        user_facing_authorize_error_message=user_facing_authorize_error_message,
                    )
                )
            else:
                raise BoltError(error_token_required())
        elif self._authorize is not None:
            self._middleware_list.append(
                MultiTeamsAuthorization(
                    authorize=self._authorize,
                    base_logger=self._base_logger,
                    user_token_resolution=self._oauth_flow.settings.user_token_resolution,
                    user_facing_authorize_error_message=user_facing_authorize_error_message,
                )
            )
        else:
            raise BoltError(error_oauth_flow_or_authorize_required())

        if ignoring_self_events_enabled is True:
            self._middleware_list.append(
                IgnoringSelfEvents(
                    base_logger=self._base_logger,
                    ignoring_self_assistant_message_events_enabled=ignoring_self_assistant_message_events_enabled,
                )
            )
        if url_verification_enabled is True:
            self._middleware_list.append(UrlVerification(base_logger=self._base_logger))
        if attaching_function_token_enabled is True:
            self._middleware_list.append(AttachingFunctionToken())
        self._init_middleware_list_done = True

    # -------------------------
    # accessors

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The name of this app (default: the filename)&#34;&#34;&#34;
        return self._name

    @property
    def oauth_flow(self) -&gt; Optional[OAuthFlow]:
        &#34;&#34;&#34;Configured `OAuthFlow` object if exists.&#34;&#34;&#34;
        return self._oauth_flow

    @property
    def logger(self) -&gt; logging.Logger:
        &#34;&#34;&#34;The logger this app uses.&#34;&#34;&#34;
        return self._framework_logger

    @property
    def client(self) -&gt; WebClient:
        &#34;&#34;&#34;The singleton `slack_sdk.WebClient` instance in this app.&#34;&#34;&#34;
        return self._client

    @property
    def installation_store(self) -&gt; Optional[InstallationStore]:
        &#34;&#34;&#34;The `slack_sdk.oauth.InstallationStore` that can be used in the `authorize` middleware.&#34;&#34;&#34;
        return self._installation_store

    @property
    def listener_runner(self) -&gt; ThreadListenerRunner:
        &#34;&#34;&#34;The thread executor for asynchronously running listeners.&#34;&#34;&#34;
        return self._listener_runner

    @property
    def process_before_response(self) -&gt; bool:
        return self._process_before_response or False

    # -------------------------
    # standalone server

    def start(
        self,
        port: int = 3000,
        path: str = &#34;/slack/events&#34;,
        http_server_logger_enabled: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;Starts a web server for local development.

            # With the default settings, `http://localhost:3000/slack/events`
            # is available for handling incoming requests from Slack
            app.start()

        This method internally starts a Web server process built with the `http.server` module.
        For production, consider using a production-ready WSGI server such as Gunicorn.

        Args:
            port: The port to listen on (Default: 3000)
            path: The path to handle request from Slack (Default: `/slack/events`)
            http_server_logger_enabled: The flag to enable http.server logging if True (Default: True)
        &#34;&#34;&#34;
        self._development_server = SlackAppDevelopmentServer(
            port=port,
            path=path,
            app=self,
            oauth_flow=self.oauth_flow,
            http_server_logger_enabled=http_server_logger_enabled,
        )
        self._development_server.start()

    # -------------------------
    # main dispatcher

    def dispatch(self, req: BoltRequest) -&gt; BoltResponse:
        &#34;&#34;&#34;Applies all middleware and dispatches an incoming request from Slack to the right code path.

        Args:
            req: An incoming request from Slack

        Returns:
            The response generated by this Bolt app
        &#34;&#34;&#34;
        starting_time = time.time()
        self._init_context(req)

        resp: Optional[BoltResponse] = BoltResponse(status=200, body=&#34;&#34;)
        middleware_state = {&#34;next_called&#34;: False}

        def middleware_next():
            middleware_state[&#34;next_called&#34;] = True

        try:
            for middleware in self._middleware_list:
                middleware_state[&#34;next_called&#34;] = False
                if self._framework_logger.level &lt;= logging.DEBUG:
                    self._framework_logger.debug(debug_applying_middleware(middleware.name))
                resp = middleware.process(req=req, resp=resp, next=middleware_next)  # type: ignore[arg-type]
                if not middleware_state[&#34;next_called&#34;]:
                    if resp is None:
                        # next() method was not called without providing the response to return to Slack
                        # This should not be an intentional handling in usual use cases.
                        resp = BoltResponse(status=404, body={&#34;error&#34;: &#34;no next() calls in middleware&#34;})
                        if self._raise_error_for_unhandled_request is True:
                            try:
                                raise BoltUnhandledRequestError(
                                    request=req,
                                    current_response=resp,
                                    last_global_middleware_name=middleware.name,
                                )
                            except BoltUnhandledRequestError as e:
                                self._listener_runner.listener_error_handler.handle(
                                    error=e,
                                    request=req,
                                    response=resp,
                                )
                            return resp
                        self._framework_logger.warning(warning_unhandled_by_global_middleware(middleware.name, req))
                        return resp
                    return resp

            for listener in self._listeners:
                listener_name = get_name_for_callable(listener.ack_function)
                self._framework_logger.debug(debug_checking_listener(listener_name))
                if listener.matches(req=req, resp=resp):  # type: ignore[arg-type]
                    # run all the middleware attached to this listener first
                    middleware_resp, next_was_not_called = listener.run_middleware(
                        req=req, resp=resp  # type: ignore[arg-type]
                    )
                    if next_was_not_called:
                        if middleware_resp is not None:
                            if self._framework_logger.level &lt;= logging.DEBUG:
                                debug_message = debug_return_listener_middleware_response(
                                    listener_name,
                                    middleware_resp.status,
                                    middleware_resp.body,
                                    starting_time,
                                )
                                self._framework_logger.debug(debug_message)
                            return middleware_resp
                        # The last listener middleware didn&#39;t call next() method.
                        # This means the listener is not for this incoming request.
                        continue

                    if middleware_resp is not None:
                        resp = middleware_resp

                    self._framework_logger.debug(debug_running_listener(listener_name))
                    listener_response: Optional[BoltResponse] = self._listener_runner.run(
                        request=req,
                        response=resp,  # type: ignore[arg-type]
                        listener_name=listener_name,
                        listener=listener,
                    )
                    if listener_response is not None:
                        return listener_response

            if resp is None:
                resp = BoltResponse(status=404, body={&#34;error&#34;: &#34;unhandled request&#34;})
            if self._raise_error_for_unhandled_request is True:
                try:
                    raise BoltUnhandledRequestError(
                        request=req,
                        current_response=resp,
                    )
                except BoltUnhandledRequestError as e:
                    self._listener_runner.listener_error_handler.handle(
                        error=e,
                        request=req,
                        response=resp,
                    )
                return resp
            return self._handle_unmatched_requests(req, resp)
        except Exception as error:
            resp = BoltResponse(status=500, body=&#34;&#34;)
            self._middleware_error_handler.handle(
                error=error,
                request=req,
                response=resp,
            )
            return resp

    def _handle_unmatched_requests(self, req: BoltRequest, resp: BoltResponse) -&gt; BoltResponse:
        self._framework_logger.warning(warning_unhandled_request(req))
        return resp

    # -------------------------
    # middleware

    def use(self, *args) -&gt; Optional[Callable]:
        &#34;&#34;&#34;Registers a new global middleware to this app. This method can be used as either a decorator or a method.

        Refer to `App#middleware()` method&#39;s docstring for details.&#34;&#34;&#34;
        return self.middleware(*args)

    def middleware(self, *args) -&gt; Optional[Callable]:
        &#34;&#34;&#34;Registers a new middleware to this app.
        This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.middleware
            def middleware_func(logger, body, next):
                logger.info(f&#34;request body: {body}&#34;)
                next()

            # Pass a function to this method
            app.middleware(middleware_func)

        Refer to https://slack.dev/bolt-python/concepts#global-middleware for details.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            *args: A function that works as a global middleware.
        &#34;&#34;&#34;
        if len(args) &gt; 0:
            middleware_or_callable = args[0]
            if isinstance(middleware_or_callable, Middleware):
                middleware: Middleware = middleware_or_callable
                self._middleware_list.append(middleware)
                if isinstance(middleware, Assistant) and middleware.thread_context_store is not None:
                    self._assistant_thread_context_store = middleware.thread_context_store
            elif callable(middleware_or_callable):
                self._middleware_list.append(
                    CustomMiddleware(
                        app_name=self.name,
                        func=middleware_or_callable,
                        base_logger=self._base_logger,
                    )
                )
                return middleware_or_callable
            else:
                raise BoltError(f&#34;Unexpected type for a middleware ({type(middleware_or_callable)})&#34;)
        return None

    # -------------------------
    # AI Agents &amp; Assistants

    def assistant(self, assistant: Assistant) -&gt; Optional[Callable]:
        return self.middleware(assistant)

    # -------------------------
    # Workflows: Steps from apps

    def step(
        self,
        callback_id: Union[str, Pattern, WorkflowStep, WorkflowStepBuilder],
        edit: Optional[Union[Callable[..., Optional[BoltResponse]], Listener, Sequence[Callable]]] = None,
        save: Optional[Union[Callable[..., Optional[BoltResponse]], Listener, Sequence[Callable]]] = None,
        execute: Optional[Union[Callable[..., Optional[BoltResponse]], Listener, Sequence[Callable]]] = None,
    ):
        &#34;&#34;&#34;
        Deprecated:
            Steps from apps for legacy workflows are now deprecated.
            Use new custom steps: https://api.slack.com/automation/functions/custom-bolt

        Registers a new step from app listener.

        Unlike others, this method doesn&#39;t behave as a decorator.
        If you want to register a step from app by a decorator, use `WorkflowStepBuilder`&#39;s methods.

            # Create a new WorkflowStep instance
            from slack_bolt.workflows.step import WorkflowStep
            ws = WorkflowStep(
                callback_id=&#34;add_task&#34;,
                edit=edit,
                save=save,
                execute=execute,
            )
            # Pass Step to set up listeners
            app.step(ws)

        Refer to https://api.slack.com/workflows/steps for details of steps from apps.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        For further information about WorkflowStep specific function arguments
        such as `configure`, `update`, `complete`, and `fail`,
        refer to `slack_bolt.workflows.step.utilities` API documents.

        Args:
            callback_id: The Callback ID for this step from app
            edit: The function for displaying a modal in the Workflow Builder
            save: The function for handling configuration in the Workflow Builder
            execute: The function for handling the step execution
        &#34;&#34;&#34;
        warnings.warn(
            (
                &#34;Steps from apps for legacy workflows are now deprecated. &#34;
                &#34;Use new custom steps: https://api.slack.com/automation/functions/custom-bolt&#34;
            ),
            category=DeprecationWarning,
        )
        step = callback_id
        if isinstance(callback_id, (str, Pattern)):
            step = WorkflowStep(
                callback_id=callback_id,
                edit=edit,  # type: ignore[arg-type]
                save=save,  # type: ignore[arg-type]
                execute=execute,  # type: ignore[arg-type]
                base_logger=self._base_logger,
            )
        elif isinstance(step, WorkflowStepBuilder):
            step = step.build(base_logger=self._base_logger)
        elif not isinstance(step, WorkflowStep):
            raise BoltError(f&#34;Invalid step object ({type(step)})&#34;)

        self.use(WorkflowStepMiddleware(step))

    # -------------------------
    # global error handler

    def error(self, func: Callable[..., Optional[BoltResponse]]) -&gt; Callable[..., Optional[BoltResponse]]:
        &#34;&#34;&#34;Updates the global error handler. This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.error
            def custom_error_handler(error, body, logger):
                logger.exception(f&#34;Error: {error}&#34;)
                logger.info(f&#34;Request body: {body}&#34;)

            # Pass a function to this method
            app.error(custom_error_handler)

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            func: The function that is supposed to be executed
                when getting an unhandled error in Bolt app.
        &#34;&#34;&#34;
        self._listener_runner.listener_error_handler = CustomListenerErrorHandler(
            logger=self._framework_logger,
            func=func,
        )
        self._middleware_error_handler = CustomMiddlewareErrorHandler(
            logger=self._framework_logger,
            func=func,
        )
        return func

    # -------------------------
    # events

    def event(
        self,
        event: Union[
            str,
            Pattern,
            Dict[str, Optional[Union[str, Sequence[Optional[Union[str, Pattern]]]]]],
        ],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new event listener. This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.event(&#34;team_join&#34;)
            def ask_for_introduction(event, say):
                welcome_channel_id = &#34;C12345&#34;
                user_id = event[&#34;user&#34;]
                text = f&#34;Welcome to the team, &lt;@{user_id}&gt;! :tada: You can introduce yourself in this channel.&#34;
                say(text=text, channel=welcome_channel_id)

            # Pass a function to this method
            app.event(&#34;team_join&#34;)(ask_for_introduction)

        Refer to https://api.slack.com/apis/connections/events-api for details of Events API.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            event: The conditions that match a request payload.
                If you pass a dict for this, you can have type, subtype in the constraint.
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.event(event, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware, True)

        return __call__

    def message(
        self,
        keyword: Union[str, Pattern] = &#34;&#34;,
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new message event listener. This method can be used as either a decorator or a method.
        Check the `App#event` method&#39;s docstring for details.

            # Use this method as a decorator
            @app.message(&#34;:wave:&#34;)
            def say_hello(message, say):
                user = message[&#39;user&#39;]
                say(f&#34;Hi there, &lt;@{user}&gt;!&#34;)

            # Pass a function to this method
            app.message(&#34;:wave:&#34;)(say_hello)

        Refer to https://api.slack.com/events/message for details of `message` events.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            keyword: The keyword to match
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;
        matchers = list(matchers) if matchers else []
        middleware = list(middleware) if middleware else []

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            constraints = {
                &#34;type&#34;: &#34;message&#34;,
                &#34;subtype&#34;: (
                    # In most cases, new message events come with no subtype.
                    None,
                    # As of Jan 2021, most bot messages no longer have the subtype bot_message.
                    # By contrast, messages posted using classic app&#39;s bot token still have the subtype.
                    &#34;bot_message&#34;,
                    # If an end-user posts a message with &#34;Also send to #channel&#34; checked,
                    # the message event comes with this subtype.
                    &#34;thread_broadcast&#34;,
                    # If an end-user posts a message with attached files,
                    # the message event comes with this subtype.
                    &#34;file_share&#34;,
                ),
            }
            primary_matcher = builtin_matchers.message_event(
                keyword=keyword, constraints=constraints, base_logger=self._base_logger
            )
            middleware.insert(0, MessageListenerMatches(keyword))
            return self._register_listener(list(functions), primary_matcher, matchers, middleware, True)

        return __call__

    def function(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
        auto_acknowledge: bool = True,
        ack_timeout: int = 3,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new Function listener.
        This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.function(&#34;reverse&#34;)
            def reverse_string(ack: Ack, inputs: dict, complete: Complete, fail: Fail):
                try:
                    ack()
                    string_to_reverse = inputs[&#34;stringToReverse&#34;]
                    complete(outputs={&#34;reverseString&#34;: string_to_reverse[::-1]})
                except Exception as e:
                    fail(f&#34;Cannot reverse string (error: {e})&#34;)
                    raise e

            # Pass a function to this method
            app.function(&#34;reverse&#34;)(reverse_string)

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            callback_id: The callback id to identify the function
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        if auto_acknowledge is True:
            if ack_timeout != 3:
                self._framework_logger.warning(warning_ack_timeout_has_no_effect(callback_id, ack_timeout))

        matchers = list(matchers) if matchers else []
        middleware = list(middleware) if middleware else []

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.function_executed(callback_id=callback_id, base_logger=self._base_logger)
            return self._register_listener(functions, primary_matcher, matchers, middleware, auto_acknowledge, ack_timeout)

        return __call__

    # -------------------------
    # slash commands

    def command(
        self,
        command: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new slash command listener.
        This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.command(&#34;/echo&#34;)
            def repeat_text(ack, say, command):
                # Acknowledge command request
                ack()
                say(f&#34;{command[&#39;text&#39;]}&#34;)

            # Pass a function to this method
            app.command(&#34;/echo&#34;)(repeat_text)

        Refer to https://api.slack.com/interactivity/slash-commands for details of Slash Commands.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            command: The conditions that match a request payload
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.command(command, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    # -------------------------
    # shortcut

    def shortcut(
        self,
        constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new shortcut listener.
        This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.shortcut(&#34;open_modal&#34;)
            def open_modal(ack, body, client):
                # Acknowledge the command request
                ack()
                # Call views_open with the built-in client
                client.views_open(
                    # Pass a valid trigger_id within 3 seconds of receiving it
                    trigger_id=body[&#34;trigger_id&#34;],
                    # View payload
                    view={ ... }
                )

            # Pass a function to this method
            app.shortcut(&#34;open_modal&#34;)(open_modal)

        Refer to https://api.slack.com/interactivity/shortcuts for details about Shortcuts.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            constraints: The conditions that match a request payload.
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.shortcut(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def global_shortcut(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new global shortcut listener.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.global_shortcut(callback_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def message_shortcut(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new message shortcut listener.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.message_shortcut(callback_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    # -------------------------
    # action

    def action(
        self,
        constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new action listener. This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.action(&#34;approve_button&#34;)
            def update_message(ack):
                ack()

            # Pass a function to this method
            app.action(&#34;approve_button&#34;)(update_message)

        * Refer to https://api.slack.com/reference/interaction-payloads/block-actions for actions in `blocks`.
        * Refer to https://api.slack.com/legacy/message-buttons for actions in `attachments`.
        * Refer to https://api.slack.com/dialogs for actions in dialogs.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            constraints: The conditions that match a request payload
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.action(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def block_action(
        self,
        constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `block_actions` action listener.
        Refer to https://api.slack.com/reference/interaction-payloads/block-actions for details.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.block_action(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def attachment_action(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `interactive_message` action listener.
        Refer to https://api.slack.com/legacy/message-buttons for details.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.attachment_action(callback_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def dialog_submission(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `dialog_submission` listener.
        Refer to https://api.slack.com/dialogs for details.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.dialog_submission(callback_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def dialog_cancellation(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `dialog_cancellation` listener.
        Refer to https://api.slack.com/dialogs for details.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.dialog_cancellation(callback_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    # -------------------------
    # view

    def view(
        self,
        constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `view_submission`/`view_closed` event listener.
        This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.view(&#34;view_1&#34;)
            def handle_submission(ack, body, client, view):
                # Assume there&#39;s an input block with `block_c` as the block_id and `dreamy_input`
                hopes_and_dreams = view[&#34;state&#34;][&#34;values&#34;][&#34;block_c&#34;][&#34;dreamy_input&#34;]
                user = body[&#34;user&#34;][&#34;id&#34;]
                # Validate the inputs
                errors = {}
                if hopes_and_dreams is not None and len(hopes_and_dreams) &lt;= 5:
                    errors[&#34;block_c&#34;] = &#34;The value must be longer than 5 characters&#34;
                if len(errors) &gt; 0:
                    ack(response_action=&#34;errors&#34;, errors=errors)
                    return
                # Acknowledge the view_submission event and close the modal
                ack()
                # Do whatever you want with the input data - here we&#39;re saving it to a DB

            # Pass a function to this method
            app.view(&#34;view_1&#34;)(handle_submission)

        Refer to https://api.slack.com/reference/interaction-payloads/views for details of payloads.

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            constraints: The conditions that match a request payload
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.view(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def view_submission(
        self,
        constraints: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `view_submission` listener.
        Refer to https://api.slack.com/reference/interaction-payloads/views#view_submission for details.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.view_submission(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def view_closed(
        self,
        constraints: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `view_closed` listener.
        Refer to https://api.slack.com/reference/interaction-payloads/views#view_closed for details.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.view_closed(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    # -------------------------
    # options

    def options(
        self,
        constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new options listener.
        This method can be used as either a decorator or a method.

            # Use this method as a decorator
            @app.options(&#34;menu_selection&#34;)
            def show_menu_options(ack):
                options = [
                    {
                        &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: &#34;Option 1&#34;},
                        &#34;value&#34;: &#34;1-1&#34;,
                    },
                    {
                        &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: &#34;Option 2&#34;},
                        &#34;value&#34;: &#34;1-2&#34;,
                    },
                ]
                ack(options=options)

            # Pass a function to this method
            app.options(&#34;menu_selection&#34;)(show_menu_options)

        Refer to the following documents for details:

        * https://api.slack.com/reference/block-kit/block-elements#external_select
        * https://api.slack.com/reference/block-kit/block-elements#external_multi_select

        To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

        Args:
            matchers: A list of listener matcher functions.
                Only when all the matchers return True, the listener function can be invoked.
            middleware: A list of lister middleware functions.
                Only when all the middleware call `next()` method, the listener function can be invoked.
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.options(constraints, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def block_suggestion(
        self,
        action_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `block_suggestion` listener.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.block_suggestion(action_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    def dialog_suggestion(
        self,
        callback_id: Union[str, Pattern],
        matchers: Optional[Sequence[Callable[..., bool]]] = None,
        middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    ) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
        &#34;&#34;&#34;Registers a new `dialog_suggestion` listener.
        Refer to https://api.slack.com/dialogs for details.&#34;&#34;&#34;

        def __call__(*args, **kwargs):
            functions = self._to_listener_functions(kwargs) if kwargs else list(args)
            primary_matcher = builtin_matchers.dialog_suggestion(callback_id, base_logger=self._base_logger)
            return self._register_listener(list(functions), primary_matcher, matchers, middleware)

        return __call__

    # -------------------------
    # built-in listener functions

    def default_tokens_revoked_event_listener(
        self,
    ) -&gt; Callable[..., Optional[BoltResponse]]:
        if self._tokens_revocation_listeners is None:
            raise BoltError(error_installation_store_required_for_builtin_listeners())
        return self._tokens_revocation_listeners.handle_tokens_revoked_events

    def default_app_uninstalled_event_listener(
        self,
    ) -&gt; Callable[..., Optional[BoltResponse]]:
        if self._tokens_revocation_listeners is None:
            raise BoltError(error_installation_store_required_for_builtin_listeners())
        return self._tokens_revocation_listeners.handle_app_uninstalled_events

    def enable_token_revocation_listeners(self) -&gt; None:
        self.event(&#34;tokens_revoked&#34;)(self.default_tokens_revoked_event_listener())
        self.event(&#34;app_uninstalled&#34;)(self.default_app_uninstalled_event_listener())

    # -------------------------

    def _init_context(self, req: BoltRequest):
        req.context[&#34;logger&#34;] = get_bolt_app_logger(app_name=self.name, base_logger=self._base_logger)
        req.context[&#34;token&#34;] = self._token
        # Prior to version 1.15, when the token is static, self._client was passed to `req.context`.
        # The intention was to avoid creating a new instance per request
        # in the interest of runtime performance/memory footprint optimization.
        # However, developers may want to replace the token held by req.context.client in some situations.
        # In this case, this behavior can result in thread-unsafe data modification on `self._client`.
        # (`self._client` a.k.a. `app.client` is a singleton object per an App instance)
        # Thus, we&#39;ve changed the behavior to create a new instance per request regardless of token argument
        # in the App initialization starting v1.15.
        # The overhead brought by this change is slight so that we believe that it is ignorable in any cases.
        client_per_request: WebClient = WebClient(
            token=self._token,  # this can be None, and it can be set later on
            base_url=self._client.base_url,
            timeout=self._client.timeout,
            ssl=self._client.ssl,
            proxy=self._client.proxy,
            headers=self._client.headers,
            team_id=req.context.team_id,
            logger=self._client.logger,
            retry_handlers=self._client.retry_handlers.copy() if self._client.retry_handlers is not None else None,
        )
        req.context[&#34;client&#34;] = client_per_request

        # Most apps do not need this &#34;listener_runner&#34; instance.
        # It is intended for apps that start lazy listeners from their custom global middleware.
        req.context[&#34;listener_runner&#34;] = self.listener_runner

        # For AI Agents &amp; Assistants
        if is_assistant_event(req.body):
            assistant = AssistantUtilities(
                payload=to_event(req.body),  # type:ignore[arg-type]
                context=req.context,
                thread_context_store=self._assistant_thread_context_store,
            )
            req.context[&#34;say&#34;] = assistant.say
            req.context[&#34;set_status&#34;] = assistant.set_status
            req.context[&#34;set_title&#34;] = assistant.set_title
            req.context[&#34;set_suggested_prompts&#34;] = assistant.set_suggested_prompts
            req.context[&#34;get_thread_context&#34;] = assistant.get_thread_context
            req.context[&#34;save_thread_context&#34;] = assistant.save_thread_context

    @staticmethod
    def _to_listener_functions(
        kwargs: dict,
    ) -&gt; Optional[Sequence[Callable[..., Optional[BoltResponse]]]]:
        if kwargs:
            functions = [kwargs[&#34;ack&#34;]]
            for sub in kwargs[&#34;lazy&#34;]:
                functions.append(sub)
            return functions
        return None

    def _register_listener(
        self,
        functions: Sequence[Callable[..., Optional[BoltResponse]]],
        primary_matcher: ListenerMatcher,
        matchers: Optional[Sequence[Callable[..., bool]]],
        middleware: Optional[Sequence[Union[Callable, Middleware]]],
        auto_acknowledgement: bool = False,
        ack_timeout: int = 3,
    ) -&gt; Optional[Callable[..., Optional[BoltResponse]]]:
        value_to_return = None
        if not isinstance(functions, list):
            functions = list(functions)
        if len(functions) == 1:
            # In the case where the function is registered using decorator,
            # the registration should return the original function.
            value_to_return = functions[0]

        listener_matchers: List[ListenerMatcher] = [
            CustomListenerMatcher(app_name=self.name, func=f, base_logger=self._base_logger) for f in (matchers or [])
        ]
        listener_matchers.insert(0, primary_matcher)
        listener_middleware = []
        for m in middleware or []:
            if isinstance(m, Middleware):
                listener_middleware.append(m)
            elif callable(m):
                listener_middleware.append(CustomMiddleware(app_name=self.name, func=m, base_logger=self._base_logger))
            else:
                raise ValueError(error_unexpected_listener_middleware(type(m)))

        self._listeners.append(
            CustomListener(
                app_name=self.name,
                ack_function=functions.pop(0),
                lazy_functions=functions,  # type:ignore[arg-type]
                matchers=listener_matchers,
                middleware=listener_middleware,
                auto_acknowledgement=auto_acknowledgement,
                ack_timeout=ack_timeout,
                base_logger=self._base_logger,
            )
        )
        return value_to_return</code></pre>
</details>
<div class="desc"><p>Bolt App that provides functionalities to register middleware/listeners.</p>
<pre><code>import os
from slack_bolt import App

# Initializes your app with your bot token and signing secret
app = App(
    token=os.environ.get("SLACK_BOT_TOKEN"),
    signing_secret=os.environ.get("SLACK_SIGNING_SECRET")
)

# Listens to incoming messages that contain "hello"
@app.message("hello")
def message_hello(message, say):
    # say() sends a message to the channel where the event was triggered
    say(f"Hey there &lt;@{message['user']}&gt;!")

# Start your app
if __name__ == "__main__":
    app.start(port=int(os.environ.get("PORT", 3000)))
</code></pre>
<p>Refer to <a href="https://slack.dev/bolt-python/tutorial/getting-started">https://slack.dev/bolt-python/tutorial/getting-started</a> for details.</p>
<p>If you would like to build an OAuth app for enabling the app to run with multiple workspaces,
refer to <a href="https://slack.dev/bolt-python/concepts#authenticating-oauth">https://slack.dev/bolt-python/concepts#authenticating-oauth</a> to learn how to configure the app.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>logger</code></strong></dt>
<dd>The custom logger that can be used in this app.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>The application name that will be used in logging. If absent, the source file name will be used.</dd>
<dt><strong><code>process_before_response</code></strong></dt>
<dd>True if this app runs on Function as a Service. (Default: False)</dd>
<dt><strong><code>raise_error_for_unhandled_request</code></strong></dt>
<dd>True if you want to raise exceptions for unhandled requests
and use @app.error listeners instead of
the built-in handler, which pints warning logs and returns 404 to Slack (Default: False)</dd>
<dt><strong><code>signing_secret</code></strong></dt>
<dd>The Signing Secret value used for verifying requests from Slack.</dd>
<dt><strong><code>token</code></strong></dt>
<dd>The bot/user access token required only for single-workspace app.</dd>
<dt><strong><code>token_verification_enabled</code></strong></dt>
<dd>Verifies the validity of the given token if True.</dd>
<dt><strong><code>client</code></strong></dt>
<dd>The singleton <code>slack_sdk.WebClient</code> instance for this app.</dd>
<dt><strong><code>before_authorize</code></strong></dt>
<dd>A global middleware that can be executed right before authorize function</dd>
<dt><strong><code>authorize</code></strong></dt>
<dd>The function to authorize an incoming request from Slack
by checking if there is a team/user in the installation data.</dd>
<dt><strong><code>user_facing_authorize_error_message</code></strong></dt>
<dd>The user-facing error message to display
when the app is installed but the installation is not managed by this app's installation store</dd>
<dt><strong><code>installation_store</code></strong></dt>
<dd>The module offering save/find operations of installation data</dd>
<dt><strong><code>installation_store_bot_only</code></strong></dt>
<dd>Use <code>InstallationStore#find_bot()</code> if True (Default: False)</dd>
<dt><strong><code>request_verification_enabled</code></strong></dt>
<dd>False if you would like to disable the built-in middleware (Default: True).
<code>RequestVerification</code> is a built-in middleware that verifies the signature in HTTP Mode requests.
Make sure if it's safe enough when you turn a built-in middleware off.
We strongly recommend using RequestVerification for better security.
If you have a proxy that verifies request signature in front of the Bolt app,
it's totally fine to disable RequestVerification to avoid duplication of work.
Don't turn it off just for easiness of development.</dd>
<dt><strong><code>ignoring_self_events_enabled</code></strong></dt>
<dd>False if you would like to disable the built-in middleware (Default: True).
<code>IgnoringSelfEvents</code> is a built-in middleware that enables Bolt apps to easily skip the events
generated by this app's bot user (this is useful for avoiding code error causing an infinite loop).</dd>
<dt><strong><code>ignoring_self_assistant_message_events_enabled</code></strong></dt>
<dd>False if you would like to disable the built-in middleware.
<code>IgnoringSelfEvents</code> for this app's bot user message events within an assistant thread
This is useful for avoiding code error causing an infinite loop; Default: True</dd>
<dt><strong><code>url_verification_enabled</code></strong></dt>
<dd>False if you would like to disable the built-in middleware (Default: True).
<code>UrlVerification</code> is a built-in middleware that handles url_verification requests
that verify the endpoint for Events API in HTTP Mode requests.</dd>
<dt><strong><code>attaching_function_token_enabled</code></strong></dt>
<dd>False if you would like to disable the built-in middleware (Default: True).
<code>AttachingFunctionToken</code> is a built-in middleware that injects the just-in-time workflow-execution tokens
when your app receives <code>function_executed</code> or interactivity events scoped to a custom step.</dd>
<dt><strong><code>ssl_check_enabled</code></strong></dt>
<dd>bool = False if you would like to disable the built-in middleware (Default: True).
<code>SslCheck</code> is a built-in middleware that handles ssl_check requests from Slack.</dd>
<dt><strong><code>oauth_settings</code></strong></dt>
<dd>The settings related to Slack app installation flow (OAuth flow)</dd>
<dt><strong><code>oauth_flow</code></strong></dt>
<dd>Instantiated <code><a title="slack_bolt.oauth.OAuthFlow" href="oauth/index.html#slack_bolt.oauth.OAuthFlow">OAuthFlow</a></code>. This is always prioritized over oauth_settings.</dd>
<dt><strong><code>verification_token</code></strong></dt>
<dd>Deprecated verification mechanism. This can be used only for ssl_check requests.</dd>
<dt><strong><code>listener_executor</code></strong></dt>
<dd>Custom executor to run background tasks. If absent, the default <code>ThreadPoolExecutor</code> will
be used.</dd>
<dt><strong><code>assistant_thread_context_store</code></strong></dt>
<dd>Custom AssistantThreadContext store (Default: the built-in implementation,
which uses a parent message's metadata to store the latest context)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="slack_bolt.App.client"><code class="name">prop <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def client(self) -&gt; WebClient:
    &#34;&#34;&#34;The singleton `slack_sdk.WebClient` instance in this app.&#34;&#34;&#34;
    return self._client</code></pre>
</details>
<div class="desc"><p>The singleton <code>slack_sdk.WebClient</code> instance in this app.</p></div>
</dd>
<dt id="slack_bolt.App.installation_store"><code class="name">prop <span class="ident">installation_store</span> : slack_sdk.oauth.installation_store.installation_store.InstallationStore | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def installation_store(self) -&gt; Optional[InstallationStore]:
    &#34;&#34;&#34;The `slack_sdk.oauth.InstallationStore` that can be used in the `authorize` middleware.&#34;&#34;&#34;
    return self._installation_store</code></pre>
</details>
<div class="desc"><p>The <code>slack_sdk.oauth.InstallationStore</code> that can be used in the <code>authorize</code> middleware.</p></div>
</dd>
<dt id="slack_bolt.App.listener_runner"><code class="name">prop <span class="ident">listener_runner</span> : <a title="slack_bolt.listener.thread_runner.ThreadListenerRunner" href="listener/thread_runner.html#slack_bolt.listener.thread_runner.ThreadListenerRunner">ThreadListenerRunner</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def listener_runner(self) -&gt; ThreadListenerRunner:
    &#34;&#34;&#34;The thread executor for asynchronously running listeners.&#34;&#34;&#34;
    return self._listener_runner</code></pre>
</details>
<div class="desc"><p>The thread executor for asynchronously running listeners.</p></div>
</dd>
<dt id="slack_bolt.App.logger"><code class="name">prop <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logger(self) -&gt; logging.Logger:
    &#34;&#34;&#34;The logger this app uses.&#34;&#34;&#34;
    return self._framework_logger</code></pre>
</details>
<div class="desc"><p>The logger this app uses.</p></div>
</dd>
<dt id="slack_bolt.App.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;The name of this app (default: the filename)&#34;&#34;&#34;
    return self._name</code></pre>
</details>
<div class="desc"><p>The name of this app (default: the filename)</p></div>
</dd>
<dt id="slack_bolt.App.oauth_flow"><code class="name">prop <span class="ident">oauth_flow</span> : <a title="slack_bolt.oauth.oauth_flow.OAuthFlow" href="oauth/oauth_flow.html#slack_bolt.oauth.oauth_flow.OAuthFlow">OAuthFlow</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def oauth_flow(self) -&gt; Optional[OAuthFlow]:
    &#34;&#34;&#34;Configured `OAuthFlow` object if exists.&#34;&#34;&#34;
    return self._oauth_flow</code></pre>
</details>
<div class="desc"><p>Configured <code>OAuthFlow</code> object if exists.</p></div>
</dd>
<dt id="slack_bolt.App.process_before_response"><code class="name">prop <span class="ident">process_before_response</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def process_before_response(self) -&gt; bool:
    return self._process_before_response or False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.App.action"><code class="name flex">
<span>def <span class="ident">action</span></span>(<span>self,<br>constraints: str | Pattern | Dict[str, str | Pattern],<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action(
    self,
    constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new action listener. This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.action(&#34;approve_button&#34;)
        def update_message(ack):
            ack()

        # Pass a function to this method
        app.action(&#34;approve_button&#34;)(update_message)

    * Refer to https://api.slack.com/reference/interaction-payloads/block-actions for actions in `blocks`.
    * Refer to https://api.slack.com/legacy/message-buttons for actions in `attachments`.
    * Refer to https://api.slack.com/dialogs for actions in dialogs.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        constraints: The conditions that match a request payload
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.action(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new action listener. This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.action("approve_button")
def update_message(ack):
    ack()

# Pass a function to this method
app.action("approve_button")(update_message)
</code></pre>
<ul>
<li>Refer to <a href="https://api.slack.com/reference/interaction-payloads/block-actions">https://api.slack.com/reference/interaction-payloads/block-actions</a> for actions in <code>blocks</code>.</li>
<li>Refer to <a href="https://api.slack.com/legacy/message-buttons">https://api.slack.com/legacy/message-buttons</a> for actions in <code>attachments</code>.</li>
<li>Refer to <a href="https://api.slack.com/dialogs">https://api.slack.com/dialogs</a> for actions in dialogs.</li>
</ul>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>constraints</code></strong></dt>
<dd>The conditions that match a request payload</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.assistant"><code class="name flex">
<span>def <span class="ident">assistant</span></span>(<span>self,<br>assistant: <a title="slack_bolt.middleware.assistant.assistant.Assistant" href="middleware/assistant/assistant.html#slack_bolt.middleware.assistant.assistant.Assistant">Assistant</a>) ‑> Callable | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assistant(self, assistant: Assistant) -&gt; Optional[Callable]:
    return self.middleware(assistant)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.App.attachment_action"><code class="name flex">
<span>def <span class="ident">attachment_action</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attachment_action(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `interactive_message` action listener.
    Refer to https://api.slack.com/legacy/message-buttons for details.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.attachment_action(callback_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>interactive_message</code> action listener.
Refer to <a href="https://api.slack.com/legacy/message-buttons">https://api.slack.com/legacy/message-buttons</a> for details.</p></div>
</dd>
<dt id="slack_bolt.App.block_action"><code class="name flex">
<span>def <span class="ident">block_action</span></span>(<span>self,<br>constraints: str | Pattern | Dict[str, str | Pattern],<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_action(
    self,
    constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `block_actions` action listener.
    Refer to https://api.slack.com/reference/interaction-payloads/block-actions for details.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.block_action(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>block_actions</code> action listener.
Refer to <a href="https://api.slack.com/reference/interaction-payloads/block-actions">https://api.slack.com/reference/interaction-payloads/block-actions</a> for details.</p></div>
</dd>
<dt id="slack_bolt.App.block_suggestion"><code class="name flex">
<span>def <span class="ident">block_suggestion</span></span>(<span>self,<br>action_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_suggestion(
    self,
    action_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `block_suggestion` listener.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.block_suggestion(action_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>block_suggestion</code> listener.</p></div>
</dd>
<dt id="slack_bolt.App.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self,<br>command: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    self,
    command: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new slash command listener.
    This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.command(&#34;/echo&#34;)
        def repeat_text(ack, say, command):
            # Acknowledge command request
            ack()
            say(f&#34;{command[&#39;text&#39;]}&#34;)

        # Pass a function to this method
        app.command(&#34;/echo&#34;)(repeat_text)

    Refer to https://api.slack.com/interactivity/slash-commands for details of Slash Commands.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        command: The conditions that match a request payload
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.command(command, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new slash command listener.
This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.command("/echo")
def repeat_text(ack, say, command):
    # Acknowledge command request
    ack()
    say(f"{command['text']}")

# Pass a function to this method
app.command("/echo")(repeat_text)
</code></pre>
<p>Refer to <a href="https://api.slack.com/interactivity/slash-commands">https://api.slack.com/interactivity/slash-commands</a> for details of Slash Commands.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>The conditions that match a request payload</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.default_app_uninstalled_event_listener"><code class="name flex">
<span>def <span class="ident">default_app_uninstalled_event_listener</span></span>(<span>self) ‑> Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_app_uninstalled_event_listener(
    self,
) -&gt; Callable[..., Optional[BoltResponse]]:
    if self._tokens_revocation_listeners is None:
        raise BoltError(error_installation_store_required_for_builtin_listeners())
    return self._tokens_revocation_listeners.handle_app_uninstalled_events</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.App.default_tokens_revoked_event_listener"><code class="name flex">
<span>def <span class="ident">default_tokens_revoked_event_listener</span></span>(<span>self) ‑> Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_tokens_revoked_event_listener(
    self,
) -&gt; Callable[..., Optional[BoltResponse]]:
    if self._tokens_revocation_listeners is None:
        raise BoltError(error_installation_store_required_for_builtin_listeners())
    return self._tokens_revocation_listeners.handle_tokens_revoked_events</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.App.dialog_cancellation"><code class="name flex">
<span>def <span class="ident">dialog_cancellation</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dialog_cancellation(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `dialog_cancellation` listener.
    Refer to https://api.slack.com/dialogs for details.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.dialog_cancellation(callback_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>dialog_cancellation</code> listener.
Refer to <a href="https://api.slack.com/dialogs">https://api.slack.com/dialogs</a> for details.</p></div>
</dd>
<dt id="slack_bolt.App.dialog_submission"><code class="name flex">
<span>def <span class="ident">dialog_submission</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dialog_submission(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `dialog_submission` listener.
    Refer to https://api.slack.com/dialogs for details.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.dialog_submission(callback_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>dialog_submission</code> listener.
Refer to <a href="https://api.slack.com/dialogs">https://api.slack.com/dialogs</a> for details.</p></div>
</dd>
<dt id="slack_bolt.App.dialog_suggestion"><code class="name flex">
<span>def <span class="ident">dialog_suggestion</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dialog_suggestion(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `dialog_suggestion` listener.
    Refer to https://api.slack.com/dialogs for details.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.dialog_suggestion(callback_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>dialog_suggestion</code> listener.
Refer to <a href="https://api.slack.com/dialogs">https://api.slack.com/dialogs</a> for details.</p></div>
</dd>
<dt id="slack_bolt.App.dispatch"><code class="name flex">
<span>def <span class="ident">dispatch</span></span>(<span>self,<br>req: <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a>) ‑> <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispatch(self, req: BoltRequest) -&gt; BoltResponse:
    &#34;&#34;&#34;Applies all middleware and dispatches an incoming request from Slack to the right code path.

    Args:
        req: An incoming request from Slack

    Returns:
        The response generated by this Bolt app
    &#34;&#34;&#34;
    starting_time = time.time()
    self._init_context(req)

    resp: Optional[BoltResponse] = BoltResponse(status=200, body=&#34;&#34;)
    middleware_state = {&#34;next_called&#34;: False}

    def middleware_next():
        middleware_state[&#34;next_called&#34;] = True

    try:
        for middleware in self._middleware_list:
            middleware_state[&#34;next_called&#34;] = False
            if self._framework_logger.level &lt;= logging.DEBUG:
                self._framework_logger.debug(debug_applying_middleware(middleware.name))
            resp = middleware.process(req=req, resp=resp, next=middleware_next)  # type: ignore[arg-type]
            if not middleware_state[&#34;next_called&#34;]:
                if resp is None:
                    # next() method was not called without providing the response to return to Slack
                    # This should not be an intentional handling in usual use cases.
                    resp = BoltResponse(status=404, body={&#34;error&#34;: &#34;no next() calls in middleware&#34;})
                    if self._raise_error_for_unhandled_request is True:
                        try:
                            raise BoltUnhandledRequestError(
                                request=req,
                                current_response=resp,
                                last_global_middleware_name=middleware.name,
                            )
                        except BoltUnhandledRequestError as e:
                            self._listener_runner.listener_error_handler.handle(
                                error=e,
                                request=req,
                                response=resp,
                            )
                        return resp
                    self._framework_logger.warning(warning_unhandled_by_global_middleware(middleware.name, req))
                    return resp
                return resp

        for listener in self._listeners:
            listener_name = get_name_for_callable(listener.ack_function)
            self._framework_logger.debug(debug_checking_listener(listener_name))
            if listener.matches(req=req, resp=resp):  # type: ignore[arg-type]
                # run all the middleware attached to this listener first
                middleware_resp, next_was_not_called = listener.run_middleware(
                    req=req, resp=resp  # type: ignore[arg-type]
                )
                if next_was_not_called:
                    if middleware_resp is not None:
                        if self._framework_logger.level &lt;= logging.DEBUG:
                            debug_message = debug_return_listener_middleware_response(
                                listener_name,
                                middleware_resp.status,
                                middleware_resp.body,
                                starting_time,
                            )
                            self._framework_logger.debug(debug_message)
                        return middleware_resp
                    # The last listener middleware didn&#39;t call next() method.
                    # This means the listener is not for this incoming request.
                    continue

                if middleware_resp is not None:
                    resp = middleware_resp

                self._framework_logger.debug(debug_running_listener(listener_name))
                listener_response: Optional[BoltResponse] = self._listener_runner.run(
                    request=req,
                    response=resp,  # type: ignore[arg-type]
                    listener_name=listener_name,
                    listener=listener,
                )
                if listener_response is not None:
                    return listener_response

        if resp is None:
            resp = BoltResponse(status=404, body={&#34;error&#34;: &#34;unhandled request&#34;})
        if self._raise_error_for_unhandled_request is True:
            try:
                raise BoltUnhandledRequestError(
                    request=req,
                    current_response=resp,
                )
            except BoltUnhandledRequestError as e:
                self._listener_runner.listener_error_handler.handle(
                    error=e,
                    request=req,
                    response=resp,
                )
            return resp
        return self._handle_unmatched_requests(req, resp)
    except Exception as error:
        resp = BoltResponse(status=500, body=&#34;&#34;)
        self._middleware_error_handler.handle(
            error=error,
            request=req,
            response=resp,
        )
        return resp</code></pre>
</details>
<div class="desc"><p>Applies all middleware and dispatches an incoming request from Slack to the right code path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong></dt>
<dd>An incoming request from Slack</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The response generated by this Bolt app</p></div>
</dd>
<dt id="slack_bolt.App.enable_token_revocation_listeners"><code class="name flex">
<span>def <span class="ident">enable_token_revocation_listeners</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_token_revocation_listeners(self) -&gt; None:
    self.event(&#34;tokens_revoked&#34;)(self.default_tokens_revoked_event_listener())
    self.event(&#34;app_uninstalled&#34;)(self.default_app_uninstalled_event_listener())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.App.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self,<br>func: Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None]) ‑> Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(self, func: Callable[..., Optional[BoltResponse]]) -&gt; Callable[..., Optional[BoltResponse]]:
    &#34;&#34;&#34;Updates the global error handler. This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.error
        def custom_error_handler(error, body, logger):
            logger.exception(f&#34;Error: {error}&#34;)
            logger.info(f&#34;Request body: {body}&#34;)

        # Pass a function to this method
        app.error(custom_error_handler)

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        func: The function that is supposed to be executed
            when getting an unhandled error in Bolt app.
    &#34;&#34;&#34;
    self._listener_runner.listener_error_handler = CustomListenerErrorHandler(
        logger=self._framework_logger,
        func=func,
    )
    self._middleware_error_handler = CustomMiddlewareErrorHandler(
        logger=self._framework_logger,
        func=func,
    )
    return func</code></pre>
</details>
<div class="desc"><p>Updates the global error handler. This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.error
def custom_error_handler(error, body, logger):
    logger.exception(f"Error: {error}")
    logger.info(f"Request body: {body}")

# Pass a function to this method
app.error(custom_error_handler)
</code></pre>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong></dt>
<dd>The function that is supposed to be executed
when getting an unhandled error in Bolt app.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self,<br>event: str | Pattern | Dict[str, str | Sequence[str | Pattern | None] | None],<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(
    self,
    event: Union[
        str,
        Pattern,
        Dict[str, Optional[Union[str, Sequence[Optional[Union[str, Pattern]]]]]],
    ],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new event listener. This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.event(&#34;team_join&#34;)
        def ask_for_introduction(event, say):
            welcome_channel_id = &#34;C12345&#34;
            user_id = event[&#34;user&#34;]
            text = f&#34;Welcome to the team, &lt;@{user_id}&gt;! :tada: You can introduce yourself in this channel.&#34;
            say(text=text, channel=welcome_channel_id)

        # Pass a function to this method
        app.event(&#34;team_join&#34;)(ask_for_introduction)

    Refer to https://api.slack.com/apis/connections/events-api for details of Events API.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        event: The conditions that match a request payload.
            If you pass a dict for this, you can have type, subtype in the constraint.
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.event(event, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware, True)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new event listener. This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.event("team_join")
def ask_for_introduction(event, say):
    welcome_channel_id = "C12345"
    user_id = event["user"]
    text = f"Welcome to the team, &lt;@{user_id}&gt;! :tada: You can introduce yourself in this channel."
    say(text=text, channel=welcome_channel_id)

# Pass a function to this method
app.event("team_join")(ask_for_introduction)
</code></pre>
<p>Refer to <a href="https://api.slack.com/apis/connections/events-api">https://api.slack.com/apis/connections/events-api</a> for details of Events API.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The conditions that match a request payload.
If you pass a dict for this, you can have type, subtype in the constraint.</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.function"><code class="name flex">
<span>def <span class="ident">function</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None,<br>auto_acknowledge: bool = True,<br>ack_timeout: int = 3) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
    auto_acknowledge: bool = True,
    ack_timeout: int = 3,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new Function listener.
    This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.function(&#34;reverse&#34;)
        def reverse_string(ack: Ack, inputs: dict, complete: Complete, fail: Fail):
            try:
                ack()
                string_to_reverse = inputs[&#34;stringToReverse&#34;]
                complete(outputs={&#34;reverseString&#34;: string_to_reverse[::-1]})
            except Exception as e:
                fail(f&#34;Cannot reverse string (error: {e})&#34;)
                raise e

        # Pass a function to this method
        app.function(&#34;reverse&#34;)(reverse_string)

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        callback_id: The callback id to identify the function
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    if auto_acknowledge is True:
        if ack_timeout != 3:
            self._framework_logger.warning(warning_ack_timeout_has_no_effect(callback_id, ack_timeout))

    matchers = list(matchers) if matchers else []
    middleware = list(middleware) if middleware else []

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.function_executed(callback_id=callback_id, base_logger=self._base_logger)
        return self._register_listener(functions, primary_matcher, matchers, middleware, auto_acknowledge, ack_timeout)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new Function listener.
This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.function("reverse")
def reverse_string(ack: Ack, inputs: dict, complete: Complete, fail: Fail):
    try:
        ack()
        string_to_reverse = inputs["stringToReverse"]
        complete(outputs={"reverseString": string_to_reverse[::-1]})
    except Exception as e:
        fail(f"Cannot reverse string (error: {e})")
        raise e

# Pass a function to this method
app.function("reverse")(reverse_string)
</code></pre>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback_id</code></strong></dt>
<dd>The callback id to identify the function</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.global_shortcut"><code class="name flex">
<span>def <span class="ident">global_shortcut</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_shortcut(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new global shortcut listener.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.global_shortcut(callback_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new global shortcut listener.</p></div>
</dd>
<dt id="slack_bolt.App.message"><code class="name flex">
<span>def <span class="ident">message</span></span>(<span>self,<br>keyword: str | Pattern = '',<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message(
    self,
    keyword: Union[str, Pattern] = &#34;&#34;,
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new message event listener. This method can be used as either a decorator or a method.
    Check the `App#event` method&#39;s docstring for details.

        # Use this method as a decorator
        @app.message(&#34;:wave:&#34;)
        def say_hello(message, say):
            user = message[&#39;user&#39;]
            say(f&#34;Hi there, &lt;@{user}&gt;!&#34;)

        # Pass a function to this method
        app.message(&#34;:wave:&#34;)(say_hello)

    Refer to https://api.slack.com/events/message for details of `message` events.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        keyword: The keyword to match
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;
    matchers = list(matchers) if matchers else []
    middleware = list(middleware) if middleware else []

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        constraints = {
            &#34;type&#34;: &#34;message&#34;,
            &#34;subtype&#34;: (
                # In most cases, new message events come with no subtype.
                None,
                # As of Jan 2021, most bot messages no longer have the subtype bot_message.
                # By contrast, messages posted using classic app&#39;s bot token still have the subtype.
                &#34;bot_message&#34;,
                # If an end-user posts a message with &#34;Also send to #channel&#34; checked,
                # the message event comes with this subtype.
                &#34;thread_broadcast&#34;,
                # If an end-user posts a message with attached files,
                # the message event comes with this subtype.
                &#34;file_share&#34;,
            ),
        }
        primary_matcher = builtin_matchers.message_event(
            keyword=keyword, constraints=constraints, base_logger=self._base_logger
        )
        middleware.insert(0, MessageListenerMatches(keyword))
        return self._register_listener(list(functions), primary_matcher, matchers, middleware, True)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new message event listener. This method can be used as either a decorator or a method.
Check the <code>App#event</code> method's docstring for details.</p>
<pre><code># Use this method as a decorator
@app.message(":wave:")
def say_hello(message, say):
    user = message['user']
    say(f"Hi there, &lt;@{user}&gt;!")

# Pass a function to this method
app.message(":wave:")(say_hello)
</code></pre>
<p>Refer to <a href="https://api.slack.com/events/message">https://api.slack.com/events/message</a> for details of <code>message</code> events.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keyword</code></strong></dt>
<dd>The keyword to match</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.message_shortcut"><code class="name flex">
<span>def <span class="ident">message_shortcut</span></span>(<span>self,<br>callback_id: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_shortcut(
    self,
    callback_id: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new message shortcut listener.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.message_shortcut(callback_id, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new message shortcut listener.</p></div>
</dd>
<dt id="slack_bolt.App.middleware"><code class="name flex">
<span>def <span class="ident">middleware</span></span>(<span>self, *args) ‑> Callable | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def middleware(self, *args) -&gt; Optional[Callable]:
    &#34;&#34;&#34;Registers a new middleware to this app.
    This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.middleware
        def middleware_func(logger, body, next):
            logger.info(f&#34;request body: {body}&#34;)
            next()

        # Pass a function to this method
        app.middleware(middleware_func)

    Refer to https://slack.dev/bolt-python/concepts#global-middleware for details.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        *args: A function that works as a global middleware.
    &#34;&#34;&#34;
    if len(args) &gt; 0:
        middleware_or_callable = args[0]
        if isinstance(middleware_or_callable, Middleware):
            middleware: Middleware = middleware_or_callable
            self._middleware_list.append(middleware)
            if isinstance(middleware, Assistant) and middleware.thread_context_store is not None:
                self._assistant_thread_context_store = middleware.thread_context_store
        elif callable(middleware_or_callable):
            self._middleware_list.append(
                CustomMiddleware(
                    app_name=self.name,
                    func=middleware_or_callable,
                    base_logger=self._base_logger,
                )
            )
            return middleware_or_callable
        else:
            raise BoltError(f&#34;Unexpected type for a middleware ({type(middleware_or_callable)})&#34;)
    return None</code></pre>
</details>
<div class="desc"><p>Registers a new middleware to this app.
This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.middleware
def middleware_func(logger, body, next):
    logger.info(f"request body: {body}")
    next()

# Pass a function to this method
app.middleware(middleware_func)
</code></pre>
<p>Refer to <a href="https://slack.dev/bolt-python/concepts#global-middleware">https://slack.dev/bolt-python/concepts#global-middleware</a> for details.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>A function that works as a global middleware.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.options"><code class="name flex">
<span>def <span class="ident">options</span></span>(<span>self,<br>constraints: str | Pattern | Dict[str, str | Pattern],<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def options(
    self,
    constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new options listener.
    This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.options(&#34;menu_selection&#34;)
        def show_menu_options(ack):
            options = [
                {
                    &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: &#34;Option 1&#34;},
                    &#34;value&#34;: &#34;1-1&#34;,
                },
                {
                    &#34;text&#34;: {&#34;type&#34;: &#34;plain_text&#34;, &#34;text&#34;: &#34;Option 2&#34;},
                    &#34;value&#34;: &#34;1-2&#34;,
                },
            ]
            ack(options=options)

        # Pass a function to this method
        app.options(&#34;menu_selection&#34;)(show_menu_options)

    Refer to the following documents for details:

    * https://api.slack.com/reference/block-kit/block-elements#external_select
    * https://api.slack.com/reference/block-kit/block-elements#external_multi_select

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.options(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new options listener.
This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.options("menu_selection")
def show_menu_options(ack):
    options = [
        {
            "text": {"type": "plain_text", "text": "Option 1"},
            "value": "1-1",
        },
        {
            "text": {"type": "plain_text", "text": "Option 2"},
            "value": "1-2",
        },
    ]
    ack(options=options)

# Pass a function to this method
app.options("menu_selection")(show_menu_options)
</code></pre>
<p>Refer to the following documents for details:</p>
<ul>
<li><a href="https://api.slack.com/reference/block-kit/block-elements#external_select">https://api.slack.com/reference/block-kit/block-elements#external_select</a></li>
<li><a href="https://api.slack.com/reference/block-kit/block-elements#external_multi_select">https://api.slack.com/reference/block-kit/block-elements#external_multi_select</a></li>
</ul>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.shortcut"><code class="name flex">
<span>def <span class="ident">shortcut</span></span>(<span>self,<br>constraints: str | Pattern | Dict[str, str | Pattern],<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortcut(
    self,
    constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new shortcut listener.
    This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.shortcut(&#34;open_modal&#34;)
        def open_modal(ack, body, client):
            # Acknowledge the command request
            ack()
            # Call views_open with the built-in client
            client.views_open(
                # Pass a valid trigger_id within 3 seconds of receiving it
                trigger_id=body[&#34;trigger_id&#34;],
                # View payload
                view={ ... }
            )

        # Pass a function to this method
        app.shortcut(&#34;open_modal&#34;)(open_modal)

    Refer to https://api.slack.com/interactivity/shortcuts for details about Shortcuts.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        constraints: The conditions that match a request payload.
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.shortcut(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new shortcut listener.
This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.shortcut("open_modal")
def open_modal(ack, body, client):
    # Acknowledge the command request
    ack()
    # Call views_open with the built-in client
    client.views_open(
        # Pass a valid trigger_id within 3 seconds of receiving it
        trigger_id=body["trigger_id"],
        # View payload
        view={ ... }
    )

# Pass a function to this method
app.shortcut("open_modal")(open_modal)
</code></pre>
<p>Refer to <a href="https://api.slack.com/interactivity/shortcuts">https://api.slack.com/interactivity/shortcuts</a> for details about Shortcuts.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>constraints</code></strong></dt>
<dd>The conditions that match a request payload.</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self,<br>port: int = 3000,<br>path: str = '/slack/events',<br>http_server_logger_enabled: bool = True) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(
    self,
    port: int = 3000,
    path: str = &#34;/slack/events&#34;,
    http_server_logger_enabled: bool = True,
) -&gt; None:
    &#34;&#34;&#34;Starts a web server for local development.

        # With the default settings, `http://localhost:3000/slack/events`
        # is available for handling incoming requests from Slack
        app.start()

    This method internally starts a Web server process built with the `http.server` module.
    For production, consider using a production-ready WSGI server such as Gunicorn.

    Args:
        port: The port to listen on (Default: 3000)
        path: The path to handle request from Slack (Default: `/slack/events`)
        http_server_logger_enabled: The flag to enable http.server logging if True (Default: True)
    &#34;&#34;&#34;
    self._development_server = SlackAppDevelopmentServer(
        port=port,
        path=path,
        app=self,
        oauth_flow=self.oauth_flow,
        http_server_logger_enabled=http_server_logger_enabled,
    )
    self._development_server.start()</code></pre>
</details>
<div class="desc"><p>Starts a web server for local development.</p>
<pre><code># With the default settings, `http://localhost:3000/slack/events`
# is available for handling incoming requests from Slack
app.start()
</code></pre>
<p>This method internally starts a Web server process built with the <code>http.server</code> module.
For production, consider using a production-ready WSGI server such as Gunicorn.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong></dt>
<dd>The port to listen on (Default: 3000)</dd>
<dt><strong><code>path</code></strong></dt>
<dd>The path to handle request from Slack (Default: <code>/slack/events</code>)</dd>
<dt><strong><code>http_server_logger_enabled</code></strong></dt>
<dd>The flag to enable http.server logging if True (Default: True)</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self,<br>callback_id: str | Pattern | <a title="slack_bolt.workflows.step.step.WorkflowStep" href="workflows/step/step.html#slack_bolt.workflows.step.step.WorkflowStep">WorkflowStep</a> | <a title="slack_bolt.workflows.step.step.WorkflowStepBuilder" href="workflows/step/step.html#slack_bolt.workflows.step.step.WorkflowStepBuilder">WorkflowStepBuilder</a>,<br>edit: Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | <a title="slack_bolt.listener.listener.Listener" href="listener/listener.html#slack_bolt.listener.listener.Listener">Listener</a> | Sequence[Callable] | None = None,<br>save: Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | <a title="slack_bolt.listener.listener.Listener" href="listener/listener.html#slack_bolt.listener.listener.Listener">Listener</a> | Sequence[Callable] | None = None,<br>execute: Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | <a title="slack_bolt.listener.listener.Listener" href="listener/listener.html#slack_bolt.listener.listener.Listener">Listener</a> | Sequence[Callable] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(
    self,
    callback_id: Union[str, Pattern, WorkflowStep, WorkflowStepBuilder],
    edit: Optional[Union[Callable[..., Optional[BoltResponse]], Listener, Sequence[Callable]]] = None,
    save: Optional[Union[Callable[..., Optional[BoltResponse]], Listener, Sequence[Callable]]] = None,
    execute: Optional[Union[Callable[..., Optional[BoltResponse]], Listener, Sequence[Callable]]] = None,
):
    &#34;&#34;&#34;
    Deprecated:
        Steps from apps for legacy workflows are now deprecated.
        Use new custom steps: https://api.slack.com/automation/functions/custom-bolt

    Registers a new step from app listener.

    Unlike others, this method doesn&#39;t behave as a decorator.
    If you want to register a step from app by a decorator, use `WorkflowStepBuilder`&#39;s methods.

        # Create a new WorkflowStep instance
        from slack_bolt.workflows.step import WorkflowStep
        ws = WorkflowStep(
            callback_id=&#34;add_task&#34;,
            edit=edit,
            save=save,
            execute=execute,
        )
        # Pass Step to set up listeners
        app.step(ws)

    Refer to https://api.slack.com/workflows/steps for details of steps from apps.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    For further information about WorkflowStep specific function arguments
    such as `configure`, `update`, `complete`, and `fail`,
    refer to `slack_bolt.workflows.step.utilities` API documents.

    Args:
        callback_id: The Callback ID for this step from app
        edit: The function for displaying a modal in the Workflow Builder
        save: The function for handling configuration in the Workflow Builder
        execute: The function for handling the step execution
    &#34;&#34;&#34;
    warnings.warn(
        (
            &#34;Steps from apps for legacy workflows are now deprecated. &#34;
            &#34;Use new custom steps: https://api.slack.com/automation/functions/custom-bolt&#34;
        ),
        category=DeprecationWarning,
    )
    step = callback_id
    if isinstance(callback_id, (str, Pattern)):
        step = WorkflowStep(
            callback_id=callback_id,
            edit=edit,  # type: ignore[arg-type]
            save=save,  # type: ignore[arg-type]
            execute=execute,  # type: ignore[arg-type]
            base_logger=self._base_logger,
        )
    elif isinstance(step, WorkflowStepBuilder):
        step = step.build(base_logger=self._base_logger)
    elif not isinstance(step, WorkflowStep):
        raise BoltError(f&#34;Invalid step object ({type(step)})&#34;)

    self.use(WorkflowStepMiddleware(step))</code></pre>
</details>
<div class="desc"><h2 id="deprecated">Deprecated</h2>
<p>Steps from apps for legacy workflows are now deprecated.
Use new custom steps: <a href="https://api.slack.com/automation/functions/custom-bolt">https://api.slack.com/automation/functions/custom-bolt</a></p>
<p>Registers a new step from app listener.</p>
<p>Unlike others, this method doesn't behave as a decorator.
If you want to register a step from app by a decorator, use <code>WorkflowStepBuilder</code>'s methods.</p>
<pre><code># Create a new WorkflowStep instance
from slack_bolt.workflows.step import WorkflowStep
ws = WorkflowStep(
    callback_id="add_task",
    edit=edit,
    save=save,
    execute=execute,
)
# Pass Step to set up listeners
app.step(ws)
</code></pre>
<p>Refer to <a href="https://api.slack.com/workflows/steps">https://api.slack.com/workflows/steps</a> for details of steps from apps.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<p>For further information about WorkflowStep specific function arguments
such as <code>configure</code>, <code>update</code>, <code>complete</code>, and <code>fail</code>,
refer to <code><a title="slack_bolt.workflows.step.utilities" href="workflows/step/utilities/index.html">slack_bolt.workflows.step.utilities</a></code> API documents.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback_id</code></strong></dt>
<dd>The Callback ID for this step from app</dd>
<dt><strong><code>edit</code></strong></dt>
<dd>The function for displaying a modal in the Workflow Builder</dd>
<dt><strong><code>save</code></strong></dt>
<dd>The function for handling configuration in the Workflow Builder</dd>
<dt><strong><code>execute</code></strong></dt>
<dd>The function for handling the step execution</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.use"><code class="name flex">
<span>def <span class="ident">use</span></span>(<span>self, *args) ‑> Callable | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use(self, *args) -&gt; Optional[Callable]:
    &#34;&#34;&#34;Registers a new global middleware to this app. This method can be used as either a decorator or a method.

    Refer to `App#middleware()` method&#39;s docstring for details.&#34;&#34;&#34;
    return self.middleware(*args)</code></pre>
</details>
<div class="desc"><p>Registers a new global middleware to this app. This method can be used as either a decorator or a method.</p>
<p>Refer to <code>App#middleware()</code> method's docstring for details.</p></div>
</dd>
<dt id="slack_bolt.App.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self,<br>constraints: str | Pattern | Dict[str, str | Pattern],<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view(
    self,
    constraints: Union[str, Pattern, Dict[str, Union[str, Pattern]]],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `view_submission`/`view_closed` event listener.
    This method can be used as either a decorator or a method.

        # Use this method as a decorator
        @app.view(&#34;view_1&#34;)
        def handle_submission(ack, body, client, view):
            # Assume there&#39;s an input block with `block_c` as the block_id and `dreamy_input`
            hopes_and_dreams = view[&#34;state&#34;][&#34;values&#34;][&#34;block_c&#34;][&#34;dreamy_input&#34;]
            user = body[&#34;user&#34;][&#34;id&#34;]
            # Validate the inputs
            errors = {}
            if hopes_and_dreams is not None and len(hopes_and_dreams) &lt;= 5:
                errors[&#34;block_c&#34;] = &#34;The value must be longer than 5 characters&#34;
            if len(errors) &gt; 0:
                ack(response_action=&#34;errors&#34;, errors=errors)
                return
            # Acknowledge the view_submission event and close the modal
            ack()
            # Do whatever you want with the input data - here we&#39;re saving it to a DB

        # Pass a function to this method
        app.view(&#34;view_1&#34;)(handle_submission)

    Refer to https://api.slack.com/reference/interaction-payloads/views for details of payloads.

    To learn available arguments for middleware/listeners, see `slack_bolt.kwargs_injection.args`&#39;s API document.

    Args:
        constraints: The conditions that match a request payload
        matchers: A list of listener matcher functions.
            Only when all the matchers return True, the listener function can be invoked.
        middleware: A list of lister middleware functions.
            Only when all the middleware call `next()` method, the listener function can be invoked.
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.view(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>view_submission</code>/<code>view_closed</code> event listener.
This method can be used as either a decorator or a method.</p>
<pre><code># Use this method as a decorator
@app.view("view_1")
def handle_submission(ack, body, client, view):
    # Assume there's an input block with &lt;code&gt;block\_c&lt;/code&gt; as the block_id and &lt;code&gt;dreamy\_input&lt;/code&gt;
    hopes_and_dreams = view["state"]["values"]["block_c"]["dreamy_input"]
    user = body["user"]["id"]
    # Validate the inputs
    errors = {}
    if hopes_and_dreams is not None and len(hopes_and_dreams) &lt;= 5:
        errors["block_c"] = "The value must be longer than 5 characters"
    if len(errors) &gt; 0:
        ack(response_action="errors", errors=errors)
        return
    # Acknowledge the view_submission event and close the modal
    ack()
    # Do whatever you want with the input data - here we're saving it to a DB

# Pass a function to this method
app.view("view_1")(handle_submission)
</code></pre>
<p>Refer to <a href="https://api.slack.com/reference/interaction-payloads/views">https://api.slack.com/reference/interaction-payloads/views</a> for details of payloads.</p>
<p>To learn available arguments for middleware/listeners, see <code><a title="slack_bolt.kwargs_injection.args" href="kwargs_injection/args.html">slack_bolt.kwargs_injection.args</a></code>'s API document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>constraints</code></strong></dt>
<dd>The conditions that match a request payload</dd>
<dt><strong><code>matchers</code></strong></dt>
<dd>A list of listener matcher functions.
Only when all the matchers return True, the listener function can be invoked.</dd>
<dt><strong><code>middleware</code></strong></dt>
<dd>A list of lister middleware functions.
Only when all the middleware call <code>next()</code> method, the listener function can be invoked.</dd>
</dl></div>
</dd>
<dt id="slack_bolt.App.view_closed"><code class="name flex">
<span>def <span class="ident">view_closed</span></span>(<span>self,<br>constraints: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_closed(
    self,
    constraints: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `view_closed` listener.
    Refer to https://api.slack.com/reference/interaction-payloads/views#view_closed for details.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.view_closed(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>view_closed</code> listener.
Refer to <a href="https://api.slack.com/reference/interaction-payloads/views#view_closed">https://api.slack.com/reference/interaction-payloads/views#view_closed</a> for details.</p></div>
</dd>
<dt id="slack_bolt.App.view_submission"><code class="name flex">
<span>def <span class="ident">view_submission</span></span>(<span>self,<br>constraints: str | Pattern,<br>matchers: Sequence[Callable[..., bool]] | None = None,<br>middleware: Sequence[Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None) ‑> Callable[..., Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_submission(
    self,
    constraints: Union[str, Pattern],
    matchers: Optional[Sequence[Callable[..., bool]]] = None,
    middleware: Optional[Sequence[Union[Callable, Middleware]]] = None,
) -&gt; Callable[..., Optional[Callable[..., Optional[BoltResponse]]]]:
    &#34;&#34;&#34;Registers a new `view_submission` listener.
    Refer to https://api.slack.com/reference/interaction-payloads/views#view_submission for details.&#34;&#34;&#34;

    def __call__(*args, **kwargs):
        functions = self._to_listener_functions(kwargs) if kwargs else list(args)
        primary_matcher = builtin_matchers.view_submission(constraints, base_logger=self._base_logger)
        return self._register_listener(list(functions), primary_matcher, matchers, middleware)

    return __call__</code></pre>
</details>
<div class="desc"><p>Registers a new <code>view_submission</code> listener.
Refer to <a href="https://api.slack.com/reference/interaction-payloads/views#view_submission">https://api.slack.com/reference/interaction-payloads/views#view_submission</a> for details.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.Args"><code class="flex name class">
<span>class <span class="ident">Args</span></span>
<span>(</span><span>*,<br>logger: logging.Logger,<br>client: slack_sdk.web.client.WebClient,<br>req: <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a>,<br>resp: <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a>,<br>context: <a title="slack_bolt.context.context.BoltContext" href="context/context.html#slack_bolt.context.context.BoltContext">BoltContext</a>,<br>body: Dict[str, Any],<br>payload: Dict[str, Any],<br>options: Dict[str, Any] | None = None,<br>shortcut: Dict[str, Any] | None = None,<br>action: Dict[str, Any] | None = None,<br>view: Dict[str, Any] | None = None,<br>command: Dict[str, Any] | None = None,<br>event: Dict[str, Any] | None = None,<br>message: Dict[str, Any] | None = None,<br>ack: <a title="slack_bolt.context.ack.ack.Ack" href="context/ack/ack.html#slack_bolt.context.ack.ack.Ack">Ack</a>,<br>say: <a title="slack_bolt.context.say.say.Say" href="context/say/say.html#slack_bolt.context.say.say.Say">Say</a>,<br>respond: <a title="slack_bolt.context.respond.respond.Respond" href="context/respond/respond.html#slack_bolt.context.respond.respond.Respond">Respond</a>,<br>complete: <a title="slack_bolt.context.complete.complete.Complete" href="context/complete/complete.html#slack_bolt.context.complete.complete.Complete">Complete</a>,<br>fail: <a title="slack_bolt.context.fail.fail.Fail" href="context/fail/fail.html#slack_bolt.context.fail.fail.Fail">Fail</a>,<br>set_status: <a title="slack_bolt.context.set_status.set_status.SetStatus" href="context/set_status/set_status.html#slack_bolt.context.set_status.set_status.SetStatus">SetStatus</a> | None = None,<br>set_title: <a title="slack_bolt.context.set_title.set_title.SetTitle" href="context/set_title/set_title.html#slack_bolt.context.set_title.set_title.SetTitle">SetTitle</a> | None = None,<br>set_suggested_prompts: <a title="slack_bolt.context.set_suggested_prompts.set_suggested_prompts.SetSuggestedPrompts" href="context/set_suggested_prompts/set_suggested_prompts.html#slack_bolt.context.set_suggested_prompts.set_suggested_prompts.SetSuggestedPrompts">SetSuggestedPrompts</a> | None = None,<br>get_thread_context: <a title="slack_bolt.context.get_thread_context.get_thread_context.GetThreadContext" href="context/get_thread_context/get_thread_context.html#slack_bolt.context.get_thread_context.get_thread_context.GetThreadContext">GetThreadContext</a> | None = None,<br>save_thread_context: <a title="slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext" href="context/save_thread_context/save_thread_context.html#slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext">SaveThreadContext</a> | None = None,<br>next: Callable[[], None],<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Args:
    &#34;&#34;&#34;All the arguments in this class are available in any middleware / listeners.
    You can inject the named variables in the argument list in arbitrary order.

        @app.action(&#34;link_button&#34;)
        def handle_buttons(ack, respond, logger, context, body, client):
            logger.info(f&#34;request body: {body}&#34;)
            ack()
            if context.channel_id is not None:
                respond(&#34;Hi!&#34;)
            client.views_open(
                trigger_id=body[&#34;trigger_id&#34;],
                view={ ... }
            )

    Alternatively, you can include a parameter named `args` and it will be injected with an instance of this class.

        @app.action(&#34;link_button&#34;)
        def handle_buttons(args):
            args.logger.info(f&#34;request body: {args.body}&#34;)
            args.ack()
            if args.context.channel_id is not None:
                args.respond(&#34;Hi!&#34;)
            args.client.views_open(
                trigger_id=args.body[&#34;trigger_id&#34;],
                view={ ... }
            )

    &#34;&#34;&#34;

    client: WebClient
    &#34;&#34;&#34;`slack_sdk.web.WebClient` instance with a valid token&#34;&#34;&#34;
    logger: Logger
    &#34;&#34;&#34;Logger instance&#34;&#34;&#34;
    req: BoltRequest
    &#34;&#34;&#34;Incoming request from Slack&#34;&#34;&#34;
    resp: BoltResponse
    &#34;&#34;&#34;Response representation&#34;&#34;&#34;
    request: BoltRequest
    &#34;&#34;&#34;Incoming request from Slack&#34;&#34;&#34;
    response: BoltResponse
    &#34;&#34;&#34;Response representation&#34;&#34;&#34;
    context: BoltContext
    &#34;&#34;&#34;Context data associated with the incoming request&#34;&#34;&#34;
    body: Dict[str, Any]
    &#34;&#34;&#34;Parsed request body data&#34;&#34;&#34;
    # payload
    payload: Dict[str, Any]
    &#34;&#34;&#34;The unwrapped core data in the request body&#34;&#34;&#34;
    options: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.options` listener&#34;&#34;&#34;
    shortcut: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.shortcut` listener&#34;&#34;&#34;
    action: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.action` listener&#34;&#34;&#34;
    view: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.view` listener&#34;&#34;&#34;
    command: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.command` listener&#34;&#34;&#34;
    event: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.event` listener&#34;&#34;&#34;
    message: Optional[Dict[str, Any]]  # payload alias
    &#34;&#34;&#34;An alias for payload in an `@app.message` listener&#34;&#34;&#34;
    # utilities
    ack: Ack
    &#34;&#34;&#34;`ack()` utility function, which returns acknowledgement to the Slack servers&#34;&#34;&#34;
    say: Say
    &#34;&#34;&#34;`say()` utility function, which calls `chat.postMessage` API with the associated channel ID&#34;&#34;&#34;
    respond: Respond
    &#34;&#34;&#34;`respond()` utility function, which utilizes the associated `response_url`&#34;&#34;&#34;
    complete: Complete
    &#34;&#34;&#34;`complete()` utility function, signals a successful completion of the custom function&#34;&#34;&#34;
    fail: Fail
    &#34;&#34;&#34;`fail()` utility function, signal that the custom function failed to complete&#34;&#34;&#34;
    set_status: Optional[SetStatus]
    &#34;&#34;&#34;`set_status()` utility function for AI Agents &amp; Assistants&#34;&#34;&#34;
    set_title: Optional[SetTitle]
    &#34;&#34;&#34;`set_title()` utility function for AI Agents &amp; Assistants&#34;&#34;&#34;
    set_suggested_prompts: Optional[SetSuggestedPrompts]
    &#34;&#34;&#34;`set_suggested_prompts()` utility function for AI Agents &amp; Assistants&#34;&#34;&#34;
    get_thread_context: Optional[GetThreadContext]
    &#34;&#34;&#34;`get_thread_context()` utility function for AI Agents &amp; Assistants&#34;&#34;&#34;
    save_thread_context: Optional[SaveThreadContext]
    &#34;&#34;&#34;`save_thread_context()` utility function for AI Agents &amp; Assistants&#34;&#34;&#34;
    # middleware
    next: Callable[[], None]
    &#34;&#34;&#34;`next()` utility function, which tells the middleware chain that it can continue with the next one&#34;&#34;&#34;
    next_: Callable[[], None]
    &#34;&#34;&#34;An alias of `next()` for avoiding the Python built-in method overrides in middleware functions&#34;&#34;&#34;

    def __init__(
        self,
        *,
        logger: logging.Logger,
        client: WebClient,
        req: BoltRequest,
        resp: BoltResponse,
        context: BoltContext,
        body: Dict[str, Any],
        payload: Dict[str, Any],
        options: Optional[Dict[str, Any]] = None,
        shortcut: Optional[Dict[str, Any]] = None,
        action: Optional[Dict[str, Any]] = None,
        view: Optional[Dict[str, Any]] = None,
        command: Optional[Dict[str, Any]] = None,
        event: Optional[Dict[str, Any]] = None,
        message: Optional[Dict[str, Any]] = None,
        ack: Ack,
        say: Say,
        respond: Respond,
        complete: Complete,
        fail: Fail,
        set_status: Optional[SetStatus] = None,
        set_title: Optional[SetTitle] = None,
        set_suggested_prompts: Optional[SetSuggestedPrompts] = None,
        get_thread_context: Optional[GetThreadContext] = None,
        save_thread_context: Optional[SaveThreadContext] = None,
        # As this method is not supposed to be invoked by bolt-python users,
        # the naming conflict with the built-in one affects
        # only the internals of this method
        next: Callable[[], None],
        **kwargs,  # noqa
    ):
        self.logger: logging.Logger = logger
        self.client: WebClient = client
        self.request = self.req = req
        self.response = self.resp = resp
        self.context: BoltContext = context

        self.body: Dict[str, Any] = body
        self.payload: Dict[str, Any] = payload
        self.options: Optional[Dict[str, Any]] = options
        self.shortcut: Optional[Dict[str, Any]] = shortcut
        self.action: Optional[Dict[str, Any]] = action
        self.view: Optional[Dict[str, Any]] = view
        self.command: Optional[Dict[str, Any]] = command
        self.event: Optional[Dict[str, Any]] = event
        self.message: Optional[Dict[str, Any]] = message

        self.ack: Ack = ack
        self.say: Say = say
        self.respond: Respond = respond
        self.complete: Complete = complete
        self.fail: Fail = fail

        self.set_status = set_status
        self.set_title = set_title
        self.set_suggested_prompts = set_suggested_prompts
        self.get_thread_context = get_thread_context
        self.save_thread_context = save_thread_context

        self.next: Callable[[], None] = next
        self.next_: Callable[[], None] = next</code></pre>
</details>
<div class="desc"><p>All the arguments in this class are available in any middleware / listeners.
You can inject the named variables in the argument list in arbitrary order.</p>
<pre><code>@app.action("link_button")
def handle_buttons(ack, respond, logger, context, body, client):
    logger.info(f"request body: {body}")
    ack()
    if context.channel_id is not None:
        respond("Hi!")
    client.views_open(
        trigger_id=body["trigger_id"],
        view={ ... }
    )
</code></pre>
<p>Alternatively, you can include a parameter named <code>args</code> and it will be injected with an instance of this class.</p>
<pre><code>@app.action("link_button")
def handle_buttons(args):
    args.logger.info(f"request body: {args.body}")
    args.ack()
    if args.context.channel_id is not None:
        args.respond("Hi!")
    args.client.views_open(
        trigger_id=args.body["trigger_id"],
        view={ ... }
    )
</code></pre></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Args.ack"><code class="name">var <span class="ident">ack</span> : <a title="slack_bolt.context.ack.ack.Ack" href="context/ack/ack.html#slack_bolt.context.ack.ack.Ack">Ack</a></code></dt>
<dd>
<div class="desc"><p><code>ack()</code> utility function, which returns acknowledgement to the Slack servers</p></div>
</dd>
<dt id="slack_bolt.Args.action"><code class="name">var <span class="ident">action</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.action</code> listener</p></div>
</dd>
<dt id="slack_bolt.Args.body"><code class="name">var <span class="ident">body</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"><p>Parsed request body data</p></div>
</dd>
<dt id="slack_bolt.Args.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<div class="desc"><p><code>slack_sdk.web.WebClient</code> instance with a valid token</p></div>
</dd>
<dt id="slack_bolt.Args.command"><code class="name">var <span class="ident">command</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.command</code> listener</p></div>
</dd>
<dt id="slack_bolt.Args.complete"><code class="name">var <span class="ident">complete</span> : <a title="slack_bolt.context.complete.complete.Complete" href="context/complete/complete.html#slack_bolt.context.complete.complete.Complete">Complete</a></code></dt>
<dd>
<div class="desc"><p><code>complete()</code> utility function, signals a successful completion of the custom function</p></div>
</dd>
<dt id="slack_bolt.Args.context"><code class="name">var <span class="ident">context</span> : <a title="slack_bolt.context.context.BoltContext" href="context/context.html#slack_bolt.context.context.BoltContext">BoltContext</a></code></dt>
<dd>
<div class="desc"><p>Context data associated with the incoming request</p></div>
</dd>
<dt id="slack_bolt.Args.event"><code class="name">var <span class="ident">event</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.event</code> listener</p></div>
</dd>
<dt id="slack_bolt.Args.fail"><code class="name">var <span class="ident">fail</span> : <a title="slack_bolt.context.fail.fail.Fail" href="context/fail/fail.html#slack_bolt.context.fail.fail.Fail">Fail</a></code></dt>
<dd>
<div class="desc"><p><code>fail()</code> utility function, signal that the custom function failed to complete</p></div>
</dd>
<dt id="slack_bolt.Args.get_thread_context"><code class="name">var <span class="ident">get_thread_context</span> : <a title="slack_bolt.context.get_thread_context.get_thread_context.GetThreadContext" href="context/get_thread_context/get_thread_context.html#slack_bolt.context.get_thread_context.get_thread_context.GetThreadContext">GetThreadContext</a> | None</code></dt>
<dd>
<div class="desc"><p><code>get_thread_context()</code> utility function for AI Agents &amp; Assistants</p></div>
</dd>
<dt id="slack_bolt.Args.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"><p>Logger instance</p></div>
</dd>
<dt id="slack_bolt.Args.message"><code class="name">var <span class="ident">message</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.message</code> listener</p></div>
</dd>
<dt id="slack_bolt.Args.next"><code class="name">var <span class="ident">next</span> : Callable[[], None]</code></dt>
<dd>
<div class="desc"><p><code>next()</code> utility function, which tells the middleware chain that it can continue with the next one</p></div>
</dd>
<dt id="slack_bolt.Args.next_"><code class="name">var <span class="ident">next_</span> : Callable[[], None]</code></dt>
<dd>
<div class="desc"><p>An alias of <code>next()</code> for avoiding the Python built-in method overrides in middleware functions</p></div>
</dd>
<dt id="slack_bolt.Args.options"><code class="name">var <span class="ident">options</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.options</code> listener</p></div>
</dd>
<dt id="slack_bolt.Args.payload"><code class="name">var <span class="ident">payload</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"><p>The unwrapped core data in the request body</p></div>
</dd>
<dt id="slack_bolt.Args.req"><code class="name">var <span class="ident">req</span> : <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a></code></dt>
<dd>
<div class="desc"><p>Incoming request from Slack</p></div>
</dd>
<dt id="slack_bolt.Args.request"><code class="name">var <span class="ident">request</span> : <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a></code></dt>
<dd>
<div class="desc"><p>Incoming request from Slack</p></div>
</dd>
<dt id="slack_bolt.Args.resp"><code class="name">var <span class="ident">resp</span> : <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a></code></dt>
<dd>
<div class="desc"><p>Response representation</p></div>
</dd>
<dt id="slack_bolt.Args.respond"><code class="name">var <span class="ident">respond</span> : <a title="slack_bolt.context.respond.respond.Respond" href="context/respond/respond.html#slack_bolt.context.respond.respond.Respond">Respond</a></code></dt>
<dd>
<div class="desc"><p><code>respond()</code> utility function, which utilizes the associated <code>response_url</code></p></div>
</dd>
<dt id="slack_bolt.Args.response"><code class="name">var <span class="ident">response</span> : <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a></code></dt>
<dd>
<div class="desc"><p>Response representation</p></div>
</dd>
<dt id="slack_bolt.Args.save_thread_context"><code class="name">var <span class="ident">save_thread_context</span> : <a title="slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext" href="context/save_thread_context/save_thread_context.html#slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext">SaveThreadContext</a> | None</code></dt>
<dd>
<div class="desc"><p><code>save_thread_context()</code> utility function for AI Agents &amp; Assistants</p></div>
</dd>
<dt id="slack_bolt.Args.say"><code class="name">var <span class="ident">say</span> : <a title="slack_bolt.context.say.say.Say" href="context/say/say.html#slack_bolt.context.say.say.Say">Say</a></code></dt>
<dd>
<div class="desc"><p><code>say()</code> utility function, which calls <code>chat.postMessage</code> API with the associated channel ID</p></div>
</dd>
<dt id="slack_bolt.Args.set_status"><code class="name">var <span class="ident">set_status</span> : <a title="slack_bolt.context.set_status.set_status.SetStatus" href="context/set_status/set_status.html#slack_bolt.context.set_status.set_status.SetStatus">SetStatus</a> | None</code></dt>
<dd>
<div class="desc"><p><code>set_status()</code> utility function for AI Agents &amp; Assistants</p></div>
</dd>
<dt id="slack_bolt.Args.set_suggested_prompts"><code class="name">var <span class="ident">set_suggested_prompts</span> : <a title="slack_bolt.context.set_suggested_prompts.set_suggested_prompts.SetSuggestedPrompts" href="context/set_suggested_prompts/set_suggested_prompts.html#slack_bolt.context.set_suggested_prompts.set_suggested_prompts.SetSuggestedPrompts">SetSuggestedPrompts</a> | None</code></dt>
<dd>
<div class="desc"><p><code>set_suggested_prompts()</code> utility function for AI Agents &amp; Assistants</p></div>
</dd>
<dt id="slack_bolt.Args.set_title"><code class="name">var <span class="ident">set_title</span> : <a title="slack_bolt.context.set_title.set_title.SetTitle" href="context/set_title/set_title.html#slack_bolt.context.set_title.set_title.SetTitle">SetTitle</a> | None</code></dt>
<dd>
<div class="desc"><p><code>set_title()</code> utility function for AI Agents &amp; Assistants</p></div>
</dd>
<dt id="slack_bolt.Args.shortcut"><code class="name">var <span class="ident">shortcut</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.shortcut</code> listener</p></div>
</dd>
<dt id="slack_bolt.Args.view"><code class="name">var <span class="ident">view</span> : Dict[str, Any] | None</code></dt>
<dd>
<div class="desc"><p>An alias for payload in an <code>@app.view</code> listener</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.Assistant"><code class="flex name class">
<span>class <span class="ident">Assistant</span></span>
<span>(</span><span>*,<br>app_name: str = 'assistant',<br>thread_context_store: <a title="slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore" href="context/assistant/thread_context_store/store.html#slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore">AssistantThreadContextStore</a> | None = None,<br>logger: logging.Logger | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Assistant(Middleware):
    _thread_started_listeners: Optional[List[Listener]]
    _thread_context_changed_listeners: Optional[List[Listener]]
    _user_message_listeners: Optional[List[Listener]]
    _bot_message_listeners: Optional[List[Listener]]

    thread_context_store: Optional[AssistantThreadContextStore]
    base_logger: Optional[logging.Logger]

    def __init__(
        self,
        *,
        app_name: str = &#34;assistant&#34;,
        thread_context_store: Optional[AssistantThreadContextStore] = None,
        logger: Optional[logging.Logger] = None,
    ):
        self.app_name = app_name
        self.thread_context_store = thread_context_store
        self.base_logger = logger

        self._thread_started_listeners = None
        self._thread_context_changed_listeners = None
        self._user_message_listeners = None
        self._bot_message_listeners = None

    def thread_started(
        self,
        *args,
        matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
        middleware: Optional[Union[Callable, Middleware]] = None,
        lazy: Optional[List[Callable[..., None]]] = None,
    ):
        if self._thread_started_listeners is None:
            self._thread_started_listeners = []
        all_matchers = self._merge_matchers(is_assistant_thread_started_event, matchers)
        if is_used_without_argument(args):
            func = args[0]
            self._thread_started_listeners.append(
                self.build_listener(
                    listener_or_functions=func,
                    matchers=all_matchers,
                    middleware=middleware,  # type:ignore[arg-type]
                )
            )
            return func

        def _inner(func):
            functions = [func] + (lazy if lazy is not None else [])
            self._thread_started_listeners.append(
                self.build_listener(
                    listener_or_functions=functions,
                    matchers=all_matchers,
                    middleware=middleware,
                )
            )

            @wraps(func)
            def _wrapper(*args, **kwargs):
                return func(*args, **kwargs)

            return _wrapper

        return _inner

    def user_message(
        self,
        *args,
        matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
        middleware: Optional[Union[Callable, Middleware]] = None,
        lazy: Optional[List[Callable[..., None]]] = None,
    ):
        if self._user_message_listeners is None:
            self._user_message_listeners = []
        all_matchers = self._merge_matchers(is_user_message_event_in_assistant_thread, matchers)
        if is_used_without_argument(args):
            func = args[0]
            self._user_message_listeners.append(
                self.build_listener(
                    listener_or_functions=func,
                    matchers=all_matchers,
                    middleware=middleware,  # type:ignore[arg-type]
                )
            )
            return func

        def _inner(func):
            functions = [func] + (lazy if lazy is not None else [])
            self._user_message_listeners.append(
                self.build_listener(
                    listener_or_functions=functions,
                    matchers=all_matchers,
                    middleware=middleware,
                )
            )

            @wraps(func)
            def _wrapper(*args, **kwargs):
                return func(*args, **kwargs)

            return _wrapper

        return _inner

    def bot_message(
        self,
        *args,
        matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
        middleware: Optional[Union[Callable, Middleware]] = None,
        lazy: Optional[List[Callable[..., None]]] = None,
    ):
        if self._bot_message_listeners is None:
            self._bot_message_listeners = []
        all_matchers = self._merge_matchers(is_bot_message_event_in_assistant_thread, matchers)
        if is_used_without_argument(args):
            func = args[0]
            self._bot_message_listeners.append(
                self.build_listener(
                    listener_or_functions=func,
                    matchers=all_matchers,
                    middleware=middleware,  # type:ignore[arg-type]
                )
            )
            return func

        def _inner(func):
            functions = [func] + (lazy if lazy is not None else [])
            self._bot_message_listeners.append(
                self.build_listener(
                    listener_or_functions=functions,
                    matchers=all_matchers,
                    middleware=middleware,
                )
            )

            @wraps(func)
            def _wrapper(*args, **kwargs):
                return func(*args, **kwargs)

            return _wrapper

        return _inner

    def thread_context_changed(
        self,
        *args,
        matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
        middleware: Optional[Union[Callable, Middleware]] = None,
        lazy: Optional[List[Callable[..., None]]] = None,
    ):
        if self._thread_context_changed_listeners is None:
            self._thread_context_changed_listeners = []
        all_matchers = self._merge_matchers(is_assistant_thread_context_changed_event, matchers)
        if is_used_without_argument(args):
            func = args[0]
            self._thread_context_changed_listeners.append(
                self.build_listener(
                    listener_or_functions=func,
                    matchers=all_matchers,
                    middleware=middleware,  # type:ignore[arg-type]
                )
            )
            return func

        def _inner(func):
            functions = [func] + (lazy if lazy is not None else [])
            self._thread_context_changed_listeners.append(
                self.build_listener(
                    listener_or_functions=functions,
                    matchers=all_matchers,
                    middleware=middleware,
                )
            )

            @wraps(func)
            def _wrapper(*args, **kwargs):
                return func(*args, **kwargs)

            return _wrapper

        return _inner

    def _merge_matchers(
        self,
        primary_matcher: Callable[..., bool],
        custom_matchers: Optional[Union[Callable[..., bool], ListenerMatcher]],
    ):
        return [CustomListenerMatcher(app_name=self.app_name, func=primary_matcher)] + (
            custom_matchers or []
        )  # type:ignore[operator]

    @staticmethod
    def default_thread_context_changed(save_thread_context: SaveThreadContext, payload: dict):
        save_thread_context(payload[&#34;assistant_thread&#34;][&#34;context&#34;])

    def process(  # type:ignore[return]
        self, *, req: BoltRequest, resp: BoltResponse, next: Callable[[], BoltResponse]
    ) -&gt; Optional[BoltResponse]:
        if self._thread_context_changed_listeners is None:
            self.thread_context_changed(self.default_thread_context_changed)

        listener_runner: ThreadListenerRunner = req.context.listener_runner
        for listeners in [
            self._thread_started_listeners,
            self._thread_context_changed_listeners,
            self._user_message_listeners,
            self._bot_message_listeners,
        ]:
            if listeners is not None:
                for listener in listeners:
                    if listener.matches(req=req, resp=resp):
                        return listener_runner.run(
                            request=req,
                            response=resp,
                            listener_name=&#34;assistant_listener&#34;,
                            listener=listener,
                        )
        if is_other_message_sub_event_in_assistant_thread(req.body):
            # message_changed, message_deleted, etc.
            return req.context.ack()

        next()

    def build_listener(
        self,
        listener_or_functions: Union[Listener, Callable, List[Callable]],
        matchers: Optional[List[Union[ListenerMatcher, Callable[..., bool]]]] = None,
        middleware: Optional[List[Middleware]] = None,
        base_logger: Optional[Logger] = None,
    ) -&gt; Listener:
        if isinstance(listener_or_functions, Callable):  # type:ignore[arg-type]
            listener_or_functions = [listener_or_functions]  # type:ignore[list-item]

        if isinstance(listener_or_functions, Listener):
            return listener_or_functions
        elif isinstance(listener_or_functions, list):
            middleware = middleware if middleware else []
            functions = listener_or_functions
            ack_function = functions.pop(0)

            matchers = matchers if matchers else []
            listener_matchers: List[ListenerMatcher] = []
            for matcher in matchers:
                if isinstance(matcher, ListenerMatcher):
                    listener_matchers.append(matcher)
                elif isinstance(matcher, Callable):  # type:ignore[arg-type]
                    listener_matchers.append(
                        build_listener_matcher(
                            func=matcher,
                            asyncio=False,
                            base_logger=base_logger,
                        )
                    )
            return CustomListener(
                app_name=self.app_name,
                matchers=listener_matchers,
                middleware=middleware,
                ack_function=ack_function,
                lazy_functions=functions,
                auto_acknowledgement=True,
                base_logger=base_logger or self.base_logger,
            )
        else:
            raise BoltError(f&#34;Invalid listener: {type(listener_or_functions)} detected&#34;)</code></pre>
</details>
<div class="desc"><p>A middleware can process request data before other middleware and listener functions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Assistant.base_logger"><code class="name">var <span class="ident">base_logger</span> : logging.Logger | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Assistant.thread_context_store"><code class="name">var <span class="ident">thread_context_store</span> : <a title="slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore" href="context/assistant/thread_context_store/store.html#slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore">AssistantThreadContextStore</a> | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="slack_bolt.Assistant.default_thread_context_changed"><code class="name flex">
<span>def <span class="ident">default_thread_context_changed</span></span>(<span>save_thread_context: <a title="slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext" href="context/save_thread_context/save_thread_context.html#slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext">SaveThreadContext</a>,<br>payload: dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def default_thread_context_changed(save_thread_context: SaveThreadContext, payload: dict):
    save_thread_context(payload[&#34;assistant_thread&#34;][&#34;context&#34;])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.Assistant.bot_message"><code class="name flex">
<span>def <span class="ident">bot_message</span></span>(<span>self,<br>*args,<br>matchers: Callable[..., bool] | <a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a> | None = None,<br>middleware: Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a> | None = None,<br>lazy: List[Callable[..., None]] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bot_message(
    self,
    *args,
    matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
    middleware: Optional[Union[Callable, Middleware]] = None,
    lazy: Optional[List[Callable[..., None]]] = None,
):
    if self._bot_message_listeners is None:
        self._bot_message_listeners = []
    all_matchers = self._merge_matchers(is_bot_message_event_in_assistant_thread, matchers)
    if is_used_without_argument(args):
        func = args[0]
        self._bot_message_listeners.append(
            self.build_listener(
                listener_or_functions=func,
                matchers=all_matchers,
                middleware=middleware,  # type:ignore[arg-type]
            )
        )
        return func

    def _inner(func):
        functions = [func] + (lazy if lazy is not None else [])
        self._bot_message_listeners.append(
            self.build_listener(
                listener_or_functions=functions,
                matchers=all_matchers,
                middleware=middleware,
            )
        )

        @wraps(func)
        def _wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        return _wrapper

    return _inner</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.Assistant.build_listener"><code class="name flex">
<span>def <span class="ident">build_listener</span></span>(<span>self,<br>listener_or_functions: <a title="slack_bolt.listener.listener.Listener" href="listener/listener.html#slack_bolt.listener.listener.Listener">Listener</a> | Callable | List[Callable],<br>matchers: List[<a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a> | Callable[..., bool]] | None = None,<br>middleware: List[<a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>] | None = None,<br>base_logger: logging.Logger | None = None) ‑> <a title="slack_bolt.listener.listener.Listener" href="listener/listener.html#slack_bolt.listener.listener.Listener">Listener</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_listener(
    self,
    listener_or_functions: Union[Listener, Callable, List[Callable]],
    matchers: Optional[List[Union[ListenerMatcher, Callable[..., bool]]]] = None,
    middleware: Optional[List[Middleware]] = None,
    base_logger: Optional[Logger] = None,
) -&gt; Listener:
    if isinstance(listener_or_functions, Callable):  # type:ignore[arg-type]
        listener_or_functions = [listener_or_functions]  # type:ignore[list-item]

    if isinstance(listener_or_functions, Listener):
        return listener_or_functions
    elif isinstance(listener_or_functions, list):
        middleware = middleware if middleware else []
        functions = listener_or_functions
        ack_function = functions.pop(0)

        matchers = matchers if matchers else []
        listener_matchers: List[ListenerMatcher] = []
        for matcher in matchers:
            if isinstance(matcher, ListenerMatcher):
                listener_matchers.append(matcher)
            elif isinstance(matcher, Callable):  # type:ignore[arg-type]
                listener_matchers.append(
                    build_listener_matcher(
                        func=matcher,
                        asyncio=False,
                        base_logger=base_logger,
                    )
                )
        return CustomListener(
            app_name=self.app_name,
            matchers=listener_matchers,
            middleware=middleware,
            ack_function=ack_function,
            lazy_functions=functions,
            auto_acknowledgement=True,
            base_logger=base_logger or self.base_logger,
        )
    else:
        raise BoltError(f&#34;Invalid listener: {type(listener_or_functions)} detected&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.Assistant.thread_context_changed"><code class="name flex">
<span>def <span class="ident">thread_context_changed</span></span>(<span>self,<br>*args,<br>matchers: Callable[..., bool] | <a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a> | None = None,<br>middleware: Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a> | None = None,<br>lazy: List[Callable[..., None]] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thread_context_changed(
    self,
    *args,
    matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
    middleware: Optional[Union[Callable, Middleware]] = None,
    lazy: Optional[List[Callable[..., None]]] = None,
):
    if self._thread_context_changed_listeners is None:
        self._thread_context_changed_listeners = []
    all_matchers = self._merge_matchers(is_assistant_thread_context_changed_event, matchers)
    if is_used_without_argument(args):
        func = args[0]
        self._thread_context_changed_listeners.append(
            self.build_listener(
                listener_or_functions=func,
                matchers=all_matchers,
                middleware=middleware,  # type:ignore[arg-type]
            )
        )
        return func

    def _inner(func):
        functions = [func] + (lazy if lazy is not None else [])
        self._thread_context_changed_listeners.append(
            self.build_listener(
                listener_or_functions=functions,
                matchers=all_matchers,
                middleware=middleware,
            )
        )

        @wraps(func)
        def _wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        return _wrapper

    return _inner</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.Assistant.thread_started"><code class="name flex">
<span>def <span class="ident">thread_started</span></span>(<span>self,<br>*args,<br>matchers: Callable[..., bool] | <a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a> | None = None,<br>middleware: Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a> | None = None,<br>lazy: List[Callable[..., None]] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thread_started(
    self,
    *args,
    matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
    middleware: Optional[Union[Callable, Middleware]] = None,
    lazy: Optional[List[Callable[..., None]]] = None,
):
    if self._thread_started_listeners is None:
        self._thread_started_listeners = []
    all_matchers = self._merge_matchers(is_assistant_thread_started_event, matchers)
    if is_used_without_argument(args):
        func = args[0]
        self._thread_started_listeners.append(
            self.build_listener(
                listener_or_functions=func,
                matchers=all_matchers,
                middleware=middleware,  # type:ignore[arg-type]
            )
        )
        return func

    def _inner(func):
        functions = [func] + (lazy if lazy is not None else [])
        self._thread_started_listeners.append(
            self.build_listener(
                listener_or_functions=functions,
                matchers=all_matchers,
                middleware=middleware,
            )
        )

        @wraps(func)
        def _wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        return _wrapper

    return _inner</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.Assistant.user_message"><code class="name flex">
<span>def <span class="ident">user_message</span></span>(<span>self,<br>*args,<br>matchers: Callable[..., bool] | <a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a> | None = None,<br>middleware: Callable | <a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a> | None = None,<br>lazy: List[Callable[..., None]] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_message(
    self,
    *args,
    matchers: Optional[Union[Callable[..., bool], ListenerMatcher]] = None,
    middleware: Optional[Union[Callable, Middleware]] = None,
    lazy: Optional[List[Callable[..., None]]] = None,
):
    if self._user_message_listeners is None:
        self._user_message_listeners = []
    all_matchers = self._merge_matchers(is_user_message_event_in_assistant_thread, matchers)
    if is_used_without_argument(args):
        func = args[0]
        self._user_message_listeners.append(
            self.build_listener(
                listener_or_functions=func,
                matchers=all_matchers,
                middleware=middleware,  # type:ignore[arg-type]
            )
        )
        return func

    def _inner(func):
        functions = [func] + (lazy if lazy is not None else [])
        self._user_message_listeners.append(
            self.build_listener(
                listener_or_functions=functions,
                matchers=all_matchers,
                middleware=middleware,
            )
        )

        @wraps(func)
        def _wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        return _wrapper

    return _inner</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a></b></code>:
<ul class="hlist">
<li><code><a title="slack_bolt.middleware.middleware.Middleware.name" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware.name">name</a></code></li>
<li><code><a title="slack_bolt.middleware.middleware.Middleware.process" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="slack_bolt.AssistantThreadContext"><code class="flex name class">
<span>class <span class="ident">AssistantThreadContext</span></span>
<span>(</span><span>payload: dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssistantThreadContext(dict):
    enterprise_id: Optional[str]
    team_id: Optional[str]
    channel_id: str

    def __init__(self, payload: dict):
        dict.__init__(self, **payload)
        self.enterprise_id = payload.get(&#34;enterprise_id&#34;)
        self.team_id = payload.get(&#34;team_id&#34;)
        self.channel_id = payload[&#34;channel_id&#34;]</code></pre>
</details>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.AssistantThreadContext.channel_id"><code class="name">var <span class="ident">channel_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.AssistantThreadContext.enterprise_id"><code class="name">var <span class="ident">enterprise_id</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.AssistantThreadContext.team_id"><code class="name">var <span class="ident">team_id</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.AssistantThreadContextStore"><code class="flex name class">
<span>class <span class="ident">AssistantThreadContextStore</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssistantThreadContextStore:
    def save(self, *, channel_id: str, thread_ts: str, context: Dict[str, str]) -&gt; None:
        raise NotImplementedError()

    def find(self, *, channel_id: str, thread_ts: str) -&gt; Optional[AssistantThreadContext]:
        raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="slack_bolt.context.assistant.thread_context_store.default_store.DefaultAssistantThreadContextStore" href="context/assistant/thread_context_store/default_store.html#slack_bolt.context.assistant.thread_context_store.default_store.DefaultAssistantThreadContextStore">DefaultAssistantThreadContextStore</a></li>
<li><a title="slack_bolt.context.assistant.thread_context_store.file.FileAssistantThreadContextStore" href="context/assistant/thread_context_store/file/index.html#slack_bolt.context.assistant.thread_context_store.file.FileAssistantThreadContextStore">FileAssistantThreadContextStore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.AssistantThreadContextStore.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *, channel_id: str, thread_ts: str) ‑> <a title="slack_bolt.context.assistant.thread_context.AssistantThreadContext" href="context/assistant/thread_context/index.html#slack_bolt.context.assistant.thread_context.AssistantThreadContext">AssistantThreadContext</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, *, channel_id: str, thread_ts: str) -&gt; Optional[AssistantThreadContext]:
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.AssistantThreadContextStore.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, *, channel_id: str, thread_ts: str, context: Dict[str, str]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, *, channel_id: str, thread_ts: str, context: Dict[str, str]) -&gt; None:
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.BoltContext"><code class="flex name class">
<span>class <span class="ident">BoltContext</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoltContext(BaseContext):
    &#34;&#34;&#34;Context object associated with a request from Slack.&#34;&#34;&#34;

    def to_copyable(self) -&gt; &#34;BoltContext&#34;:
        new_dict = {}
        for prop_name, prop_value in self.items():
            if prop_name in self.copyable_standard_property_names:
                # all the standard properties are copiable
                new_dict[prop_name] = prop_value
            elif prop_name in self.non_copyable_standard_property_names:
                # Do nothing with this property (e.g., listener_runner)
                continue
            else:
                try:
                    copied_value = create_copy(prop_value)
                    new_dict[prop_name] = copied_value
                except TypeError as te:
                    self.logger.warning(
                        f&#34;Skipped setting &#39;{prop_name}&#39; to a copied request for lazy listeners &#34;
                        &#34;due to a deep-copy creation error. Consider passing the value not as part of context object &#34;
                        f&#34;(error: {te})&#34;
                    )
        return BoltContext(new_dict)

    # The return type is intentionally string to avoid circular imports
    @property
    def listener_runner(self) -&gt; &#34;ThreadListenerRunner&#34;:  # type: ignore[name-defined]
        &#34;&#34;&#34;The properly configured listener_runner that is available for middleware/listeners.&#34;&#34;&#34;
        return self[&#34;listener_runner&#34;]

    @property
    def client(self) -&gt; WebClient:
        &#34;&#34;&#34;The `WebClient` instance available for this request.

            @app.event(&#34;app_mention&#34;)
            def handle_events(context):
                context.client.chat_postMessage(
                    channel=context.channel_id,
                    text=&#34;Thanks!&#34;,
                )

            # You can access &#34;client&#34; this way too.
            @app.event(&#34;app_mention&#34;)
            def handle_events(client, context):
                client.chat_postMessage(
                    channel=context.channel_id,
                    text=&#34;Thanks!&#34;,
                )

        Returns:
            `WebClient` instance
        &#34;&#34;&#34;
        if &#34;client&#34; not in self:
            self[&#34;client&#34;] = WebClient(token=None)
        return self[&#34;client&#34;]

    @property
    def ack(self) -&gt; Ack:
        &#34;&#34;&#34;`ack()` function for this request.

            @app.action(&#34;button&#34;)
            def handle_button_clicks(context):
                context.ack()

            # You can access &#34;ack&#34; this way too.
            @app.action(&#34;button&#34;)
            def handle_button_clicks(ack):
                ack()

        Returns:
            Callable `ack()` function
        &#34;&#34;&#34;
        if &#34;ack&#34; not in self:
            self[&#34;ack&#34;] = Ack()
        return self[&#34;ack&#34;]

    @property
    def say(self) -&gt; Say:
        &#34;&#34;&#34;`say()` function for this request.

            @app.action(&#34;button&#34;)
            def handle_button_clicks(context):
                context.ack()
                context.say(&#34;Hi!&#34;)

            # You can access &#34;ack&#34; this way too.
            @app.action(&#34;button&#34;)
            def handle_button_clicks(ack, say):
                ack()
                say(&#34;Hi!&#34;)

        Returns:
            Callable `say()` function
        &#34;&#34;&#34;
        if &#34;say&#34; not in self:
            self[&#34;say&#34;] = Say(client=self.client, channel=self.channel_id, thread_ts=self.thread_ts)
        return self[&#34;say&#34;]

    @property
    def respond(self) -&gt; Optional[Respond]:
        &#34;&#34;&#34;`respond()` function for this request.

            @app.action(&#34;button&#34;)
            def handle_button_clicks(context):
                context.ack()
                context.respond(&#34;Hi!&#34;)

            # You can access &#34;ack&#34; this way too.
            @app.action(&#34;button&#34;)
            def handle_button_clicks(ack, respond):
                ack()
                respond(&#34;Hi!&#34;)

        Returns:
            Callable `respond()` function
        &#34;&#34;&#34;
        if &#34;respond&#34; not in self:
            self[&#34;respond&#34;] = Respond(
                response_url=self.response_url,
                proxy=self.client.proxy,
                ssl=self.client.ssl,
            )
        return self[&#34;respond&#34;]

    @property
    def complete(self) -&gt; Complete:
        &#34;&#34;&#34;`complete()` function for this request. Once a custom function&#39;s state is set to complete,
        any outputs the function returns will be passed along to the next step of its housing workflow,
        or complete the workflow if the function is the last step in a workflow. Additionally,
        any interactivity handlers associated to a function invocation will no longer be invocable.

            @app.function(&#34;reverse&#34;)
            def handle_button_clicks(ack, complete):
                ack()
                complete(outputs={&#34;stringReverse&#34;:&#34;olleh&#34;})

            @app.function(&#34;reverse&#34;)
            def handle_button_clicks(context):
                context.ack()
                context.complete(outputs={&#34;stringReverse&#34;:&#34;olleh&#34;})

        Returns:
            Callable `complete()` function
        &#34;&#34;&#34;
        if &#34;complete&#34; not in self:
            self[&#34;complete&#34;] = Complete(client=self.client, function_execution_id=self.function_execution_id)
        return self[&#34;complete&#34;]

    @property
    def fail(self) -&gt; Fail:
        &#34;&#34;&#34;`fail()` function for this request. Once a custom function&#39;s state is set to error,
        its housing workflow will be interrupted and any provided error message will be passed
        on to the end user through SlackBot. Additionally, any interactivity handlers associated
        to a function invocation will no longer be invocable.

            @app.function(&#34;reverse&#34;)
            def handle_button_clicks(ack, fail):
                ack()
                fail(error=&#34;something went wrong&#34;)

            @app.function(&#34;reverse&#34;)
            def handle_button_clicks(context):
                context.ack()
                context.fail(error=&#34;something went wrong&#34;)

        Returns:
            Callable `fail()` function
        &#34;&#34;&#34;
        if &#34;fail&#34; not in self:
            self[&#34;fail&#34;] = Fail(client=self.client, function_execution_id=self.function_execution_id)
        return self[&#34;fail&#34;]

    @property
    def set_title(self) -&gt; Optional[SetTitle]:
        return self.get(&#34;set_title&#34;)

    @property
    def set_status(self) -&gt; Optional[SetStatus]:
        return self.get(&#34;set_status&#34;)

    @property
    def set_suggested_prompts(self) -&gt; Optional[SetSuggestedPrompts]:
        return self.get(&#34;set_suggested_prompts&#34;)

    @property
    def get_thread_context(self) -&gt; Optional[GetThreadContext]:
        return self.get(&#34;get_thread_context&#34;)

    @property
    def save_thread_context(self) -&gt; Optional[SaveThreadContext]:
        return self.get(&#34;save_thread_context&#34;)</code></pre>
</details>
<div class="desc"><p>Context object associated with a request from Slack.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_bolt.context.base_context.BaseContext" href="context/base_context.html#slack_bolt.context.base_context.BaseContext">BaseContext</a></li>
<li>builtins.dict</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="slack_bolt.BoltContext.ack"><code class="name">prop <span class="ident">ack</span> : <a title="slack_bolt.context.ack.ack.Ack" href="context/ack/ack.html#slack_bolt.context.ack.ack.Ack">Ack</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ack(self) -&gt; Ack:
    &#34;&#34;&#34;`ack()` function for this request.

        @app.action(&#34;button&#34;)
        def handle_button_clicks(context):
            context.ack()

        # You can access &#34;ack&#34; this way too.
        @app.action(&#34;button&#34;)
        def handle_button_clicks(ack):
            ack()

    Returns:
        Callable `ack()` function
    &#34;&#34;&#34;
    if &#34;ack&#34; not in self:
        self[&#34;ack&#34;] = Ack()
    return self[&#34;ack&#34;]</code></pre>
</details>
<div class="desc"><p><code>ack()</code> function for this request.</p>
<pre><code>@app.action("button")
def handle_button_clicks(context):
    context.ack()

# You can access "ack" this way too.
@app.action("button")
def handle_button_clicks(ack):
    ack()
</code></pre>
<h2 id="returns">Returns</h2>
<p>Callable <code>ack()</code> function</p></div>
</dd>
<dt id="slack_bolt.BoltContext.client"><code class="name">prop <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def client(self) -&gt; WebClient:
    &#34;&#34;&#34;The `WebClient` instance available for this request.

        @app.event(&#34;app_mention&#34;)
        def handle_events(context):
            context.client.chat_postMessage(
                channel=context.channel_id,
                text=&#34;Thanks!&#34;,
            )

        # You can access &#34;client&#34; this way too.
        @app.event(&#34;app_mention&#34;)
        def handle_events(client, context):
            client.chat_postMessage(
                channel=context.channel_id,
                text=&#34;Thanks!&#34;,
            )

    Returns:
        `WebClient` instance
    &#34;&#34;&#34;
    if &#34;client&#34; not in self:
        self[&#34;client&#34;] = WebClient(token=None)
    return self[&#34;client&#34;]</code></pre>
</details>
<div class="desc"><p>The <code>WebClient</code> instance available for this request.</p>
<pre><code>@app.event("app_mention")
def handle_events(context):
    context.client.chat_postMessage(
        channel=context.channel_id,
        text="Thanks!",
    )

# You can access "client" this way too.
@app.event("app_mention")
def handle_events(client, context):
    client.chat_postMessage(
        channel=context.channel_id,
        text="Thanks!",
    )
</code></pre>
<h2 id="returns">Returns</h2>
<p><code>WebClient</code> instance</p></div>
</dd>
<dt id="slack_bolt.BoltContext.complete"><code class="name">prop <span class="ident">complete</span> : <a title="slack_bolt.context.complete.complete.Complete" href="context/complete/complete.html#slack_bolt.context.complete.complete.Complete">Complete</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def complete(self) -&gt; Complete:
    &#34;&#34;&#34;`complete()` function for this request. Once a custom function&#39;s state is set to complete,
    any outputs the function returns will be passed along to the next step of its housing workflow,
    or complete the workflow if the function is the last step in a workflow. Additionally,
    any interactivity handlers associated to a function invocation will no longer be invocable.

        @app.function(&#34;reverse&#34;)
        def handle_button_clicks(ack, complete):
            ack()
            complete(outputs={&#34;stringReverse&#34;:&#34;olleh&#34;})

        @app.function(&#34;reverse&#34;)
        def handle_button_clicks(context):
            context.ack()
            context.complete(outputs={&#34;stringReverse&#34;:&#34;olleh&#34;})

    Returns:
        Callable `complete()` function
    &#34;&#34;&#34;
    if &#34;complete&#34; not in self:
        self[&#34;complete&#34;] = Complete(client=self.client, function_execution_id=self.function_execution_id)
    return self[&#34;complete&#34;]</code></pre>
</details>
<div class="desc"><p><code>complete()</code> function for this request. Once a custom function's state is set to complete,
any outputs the function returns will be passed along to the next step of its housing workflow,
or complete the workflow if the function is the last step in a workflow. Additionally,
any interactivity handlers associated to a function invocation will no longer be invocable.</p>
<pre><code>@app.function("reverse")
def handle_button_clicks(ack, complete):
    ack()
    complete(outputs={"stringReverse":"olleh"})

@app.function("reverse")
def handle_button_clicks(context):
    context.ack()
    context.complete(outputs={"stringReverse":"olleh"})
</code></pre>
<h2 id="returns">Returns</h2>
<p>Callable <code>complete()</code> function</p></div>
</dd>
<dt id="slack_bolt.BoltContext.fail"><code class="name">prop <span class="ident">fail</span> : <a title="slack_bolt.context.fail.fail.Fail" href="context/fail/fail.html#slack_bolt.context.fail.fail.Fail">Fail</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fail(self) -&gt; Fail:
    &#34;&#34;&#34;`fail()` function for this request. Once a custom function&#39;s state is set to error,
    its housing workflow will be interrupted and any provided error message will be passed
    on to the end user through SlackBot. Additionally, any interactivity handlers associated
    to a function invocation will no longer be invocable.

        @app.function(&#34;reverse&#34;)
        def handle_button_clicks(ack, fail):
            ack()
            fail(error=&#34;something went wrong&#34;)

        @app.function(&#34;reverse&#34;)
        def handle_button_clicks(context):
            context.ack()
            context.fail(error=&#34;something went wrong&#34;)

    Returns:
        Callable `fail()` function
    &#34;&#34;&#34;
    if &#34;fail&#34; not in self:
        self[&#34;fail&#34;] = Fail(client=self.client, function_execution_id=self.function_execution_id)
    return self[&#34;fail&#34;]</code></pre>
</details>
<div class="desc"><p><code>fail()</code> function for this request. Once a custom function's state is set to error,
its housing workflow will be interrupted and any provided error message will be passed
on to the end user through SlackBot. Additionally, any interactivity handlers associated
to a function invocation will no longer be invocable.</p>
<pre><code>@app.function("reverse")
def handle_button_clicks(ack, fail):
    ack()
    fail(error="something went wrong")

@app.function("reverse")
def handle_button_clicks(context):
    context.ack()
    context.fail(error="something went wrong")
</code></pre>
<h2 id="returns">Returns</h2>
<p>Callable <code>fail()</code> function</p></div>
</dd>
<dt id="slack_bolt.BoltContext.get_thread_context"><code class="name">prop <span class="ident">get_thread_context</span> : <a title="slack_bolt.context.get_thread_context.get_thread_context.GetThreadContext" href="context/get_thread_context/get_thread_context.html#slack_bolt.context.get_thread_context.get_thread_context.GetThreadContext">GetThreadContext</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def get_thread_context(self) -&gt; Optional[GetThreadContext]:
    return self.get(&#34;get_thread_context&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.BoltContext.listener_runner"><code class="name">prop <span class="ident">listener_runner</span> : ThreadListenerRunner</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def listener_runner(self) -&gt; &#34;ThreadListenerRunner&#34;:  # type: ignore[name-defined]
    &#34;&#34;&#34;The properly configured listener_runner that is available for middleware/listeners.&#34;&#34;&#34;
    return self[&#34;listener_runner&#34;]</code></pre>
</details>
<div class="desc"><p>The properly configured listener_runner that is available for middleware/listeners.</p></div>
</dd>
<dt id="slack_bolt.BoltContext.respond"><code class="name">prop <span class="ident">respond</span> : <a title="slack_bolt.context.respond.respond.Respond" href="context/respond/respond.html#slack_bolt.context.respond.respond.Respond">Respond</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def respond(self) -&gt; Optional[Respond]:
    &#34;&#34;&#34;`respond()` function for this request.

        @app.action(&#34;button&#34;)
        def handle_button_clicks(context):
            context.ack()
            context.respond(&#34;Hi!&#34;)

        # You can access &#34;ack&#34; this way too.
        @app.action(&#34;button&#34;)
        def handle_button_clicks(ack, respond):
            ack()
            respond(&#34;Hi!&#34;)

    Returns:
        Callable `respond()` function
    &#34;&#34;&#34;
    if &#34;respond&#34; not in self:
        self[&#34;respond&#34;] = Respond(
            response_url=self.response_url,
            proxy=self.client.proxy,
            ssl=self.client.ssl,
        )
    return self[&#34;respond&#34;]</code></pre>
</details>
<div class="desc"><p><code>respond()</code> function for this request.</p>
<pre><code>@app.action("button")
def handle_button_clicks(context):
    context.ack()
    context.respond("Hi!")

# You can access "ack" this way too.
@app.action("button")
def handle_button_clicks(ack, respond):
    ack()
    respond("Hi!")
</code></pre>
<h2 id="returns">Returns</h2>
<p>Callable <code>respond()</code> function</p></div>
</dd>
<dt id="slack_bolt.BoltContext.save_thread_context"><code class="name">prop <span class="ident">save_thread_context</span> : <a title="slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext" href="context/save_thread_context/save_thread_context.html#slack_bolt.context.save_thread_context.save_thread_context.SaveThreadContext">SaveThreadContext</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def save_thread_context(self) -&gt; Optional[SaveThreadContext]:
    return self.get(&#34;save_thread_context&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.BoltContext.say"><code class="name">prop <span class="ident">say</span> : <a title="slack_bolt.context.say.say.Say" href="context/say/say.html#slack_bolt.context.say.say.Say">Say</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def say(self) -&gt; Say:
    &#34;&#34;&#34;`say()` function for this request.

        @app.action(&#34;button&#34;)
        def handle_button_clicks(context):
            context.ack()
            context.say(&#34;Hi!&#34;)

        # You can access &#34;ack&#34; this way too.
        @app.action(&#34;button&#34;)
        def handle_button_clicks(ack, say):
            ack()
            say(&#34;Hi!&#34;)

    Returns:
        Callable `say()` function
    &#34;&#34;&#34;
    if &#34;say&#34; not in self:
        self[&#34;say&#34;] = Say(client=self.client, channel=self.channel_id, thread_ts=self.thread_ts)
    return self[&#34;say&#34;]</code></pre>
</details>
<div class="desc"><p><code>say()</code> function for this request.</p>
<pre><code>@app.action("button")
def handle_button_clicks(context):
    context.ack()
    context.say("Hi!")

# You can access "ack" this way too.
@app.action("button")
def handle_button_clicks(ack, say):
    ack()
    say("Hi!")
</code></pre>
<h2 id="returns">Returns</h2>
<p>Callable <code>say()</code> function</p></div>
</dd>
<dt id="slack_bolt.BoltContext.set_status"><code class="name">prop <span class="ident">set_status</span> : <a title="slack_bolt.context.set_status.set_status.SetStatus" href="context/set_status/set_status.html#slack_bolt.context.set_status.set_status.SetStatus">SetStatus</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def set_status(self) -&gt; Optional[SetStatus]:
    return self.get(&#34;set_status&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.BoltContext.set_suggested_prompts"><code class="name">prop <span class="ident">set_suggested_prompts</span> : <a title="slack_bolt.context.set_suggested_prompts.set_suggested_prompts.SetSuggestedPrompts" href="context/set_suggested_prompts/set_suggested_prompts.html#slack_bolt.context.set_suggested_prompts.set_suggested_prompts.SetSuggestedPrompts">SetSuggestedPrompts</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def set_suggested_prompts(self) -&gt; Optional[SetSuggestedPrompts]:
    return self.get(&#34;set_suggested_prompts&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.BoltContext.set_title"><code class="name">prop <span class="ident">set_title</span> : <a title="slack_bolt.context.set_title.set_title.SetTitle" href="context/set_title/set_title.html#slack_bolt.context.set_title.set_title.SetTitle">SetTitle</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def set_title(self) -&gt; Optional[SetTitle]:
    return self.get(&#34;set_title&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.BoltContext.to_copyable"><code class="name flex">
<span>def <span class="ident">to_copyable</span></span>(<span>self) ‑> <a title="slack_bolt.context.context.BoltContext" href="context/context.html#slack_bolt.context.context.BoltContext">BoltContext</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_copyable(self) -&gt; &#34;BoltContext&#34;:
    new_dict = {}
    for prop_name, prop_value in self.items():
        if prop_name in self.copyable_standard_property_names:
            # all the standard properties are copiable
            new_dict[prop_name] = prop_value
        elif prop_name in self.non_copyable_standard_property_names:
            # Do nothing with this property (e.g., listener_runner)
            continue
        else:
            try:
                copied_value = create_copy(prop_value)
                new_dict[prop_name] = copied_value
            except TypeError as te:
                self.logger.warning(
                    f&#34;Skipped setting &#39;{prop_name}&#39; to a copied request for lazy listeners &#34;
                    &#34;due to a deep-copy creation error. Consider passing the value not as part of context object &#34;
                    f&#34;(error: {te})&#34;
                )
    return BoltContext(new_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="slack_bolt.context.base_context.BaseContext" href="context/base_context.html#slack_bolt.context.base_context.BaseContext">BaseContext</a></b></code>:
<ul class="hlist">
<li><code><a title="slack_bolt.context.base_context.BaseContext.actor_enterprise_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.actor_enterprise_id">actor_enterprise_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.actor_team_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.actor_team_id">actor_team_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.actor_user_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.actor_user_id">actor_user_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.authorize_result" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.authorize_result">authorize_result</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.bot_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.bot_id">bot_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.bot_token" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.bot_token">bot_token</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.bot_user_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.bot_user_id">bot_user_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.channel_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.channel_id">channel_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.copyable_standard_property_names" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.copyable_standard_property_names">copyable_standard_property_names</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.enterprise_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.enterprise_id">enterprise_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.function_bot_access_token" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.function_bot_access_token">function_bot_access_token</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.function_execution_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.function_execution_id">function_execution_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.inputs" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.inputs">inputs</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.is_enterprise_install" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.is_enterprise_install">is_enterprise_install</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.logger" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.logger">logger</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.matches" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.matches">matches</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.non_copyable_standard_property_names" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.non_copyable_standard_property_names">non_copyable_standard_property_names</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.response_url" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.response_url">response_url</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.standard_property_names" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.standard_property_names">standard_property_names</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.team_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.team_id">team_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.thread_ts" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.thread_ts">thread_ts</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.token" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.token">token</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.user_id" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.user_id">user_id</a></code></li>
<li><code><a title="slack_bolt.context.base_context.BaseContext.user_token" href="context/base_context.html#slack_bolt.context.base_context.BaseContext.user_token">user_token</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="slack_bolt.BoltRequest"><code class="flex name class">
<span>class <span class="ident">BoltRequest</span></span>
<span>(</span><span>*,<br>body: str | dict,<br>query: str | Dict[str, str] | Dict[str, Sequence[str]] | None = None,<br>headers: Dict[str, str | Sequence[str]] | None = None,<br>context: Dict[str, Any] | None = None,<br>mode: str = 'http')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoltRequest:
    raw_body: str
    query: Dict[str, Sequence[str]]
    headers: Dict[str, Sequence[str]]
    content_type: Optional[str]
    body: Dict[str, Any]
    context: BoltContext
    lazy_only: bool
    lazy_function_name: Optional[str]
    mode: str  # either &#34;http&#34; or &#34;socket_mode&#34;

    def __init__(
        self,
        *,
        body: Union[str, dict],
        query: Optional[Union[str, Dict[str, str], Dict[str, Sequence[str]]]] = None,
        headers: Optional[Dict[str, Union[str, Sequence[str]]]] = None,
        context: Optional[Dict[str, Any]] = None,
        mode: str = &#34;http&#34;,  # either &#34;http&#34; or &#34;socket_mode&#34;
    ):
        &#34;&#34;&#34;Request to a Bolt app.

        Args:
            body: The raw request body (only plain text is supported for &#34;http&#34; mode)
            query: The query string data in any data format.
            headers: The request headers.
            context: The context in this request.
            mode: The mode used for this request. (either &#34;http&#34; or &#34;socket_mode&#34;)
        &#34;&#34;&#34;
        if mode == &#34;http&#34;:
            # HTTP Mode
            if body is not None and not isinstance(body, str):
                raise BoltError(error_message_raw_body_required_in_http_mode())
            self.raw_body = body if body is not None else &#34;&#34;
        else:
            # Socket Mode
            if body is not None and isinstance(body, str):
                self.raw_body = body
            else:
                # We don&#39;t convert the dict value to str
                # as doing so does not guarantee to keep the original structure/format.
                self.raw_body = &#34;&#34;

        self.query = parse_query(query)
        self.headers = build_normalized_headers(headers)
        self.content_type = extract_content_type(self.headers)

        if isinstance(body, str):
            self.body = parse_body(self.raw_body, self.content_type)
        elif isinstance(body, dict):
            self.body = body
        else:
            self.body = {}

        self.context = build_context(BoltContext(context if context else {}), self.body)
        self.lazy_only = bool(self.headers.get(&#34;x-slack-bolt-lazy-only&#34;, [False])[0])
        self.lazy_function_name = self.headers.get(&#34;x-slack-bolt-lazy-function-name&#34;, [None])[0]
        self.mode = mode

    def to_copyable(self) -&gt; &#34;BoltRequest&#34;:
        body: Union[str, dict] = self.raw_body if self.mode == &#34;http&#34; else self.body
        return BoltRequest(
            body=body,
            query=self.query,
            headers=self.headers,
            context=self.context.to_copyable(),
            mode=self.mode,
        )</code></pre>
</details>
<div class="desc"><p>Request to a Bolt app.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>body</code></strong></dt>
<dd>The raw request body (only plain text is supported for "http" mode)</dd>
<dt><strong><code>query</code></strong></dt>
<dd>The query string data in any data format.</dd>
<dt><strong><code>headers</code></strong></dt>
<dd>The request headers.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>The context in this request.</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>The mode used for this request. (either "http" or "socket_mode")</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.BoltRequest.body"><code class="name">var <span class="ident">body</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.content_type"><code class="name">var <span class="ident">content_type</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.context"><code class="name">var <span class="ident">context</span> : <a title="slack_bolt.context.context.BoltContext" href="context/context.html#slack_bolt.context.context.BoltContext">BoltContext</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.headers"><code class="name">var <span class="ident">headers</span> : Dict[str, Sequence[str]]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.lazy_function_name"><code class="name">var <span class="ident">lazy_function_name</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.lazy_only"><code class="name">var <span class="ident">lazy_only</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.mode"><code class="name">var <span class="ident">mode</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.query"><code class="name">var <span class="ident">query</span> : Dict[str, Sequence[str]]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltRequest.raw_body"><code class="name">var <span class="ident">raw_body</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.BoltRequest.to_copyable"><code class="name flex">
<span>def <span class="ident">to_copyable</span></span>(<span>self) ‑> <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_copyable(self) -&gt; &#34;BoltRequest&#34;:
    body: Union[str, dict] = self.raw_body if self.mode == &#34;http&#34; else self.body
    return BoltRequest(
        body=body,
        query=self.query,
        headers=self.headers,
        context=self.context.to_copyable(),
        mode=self.mode,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.BoltResponse"><code class="flex name class">
<span>class <span class="ident">BoltResponse</span></span>
<span>(</span><span>*,<br>status: int,<br>body: str | dict = '',<br>headers: Dict[str, str | Sequence[str]] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoltResponse:
    status: int
    body: str
    headers: Dict[str, Sequence[str]]

    def __init__(
        self,
        *,
        status: int,
        body: Union[str, dict] = &#34;&#34;,
        headers: Optional[Dict[str, Union[str, Sequence[str]]]] = None,
    ):
        &#34;&#34;&#34;The response from a Bolt app.

        Args:
            status: HTTP status code
            body: The response body (dict and str are supported)
            headers: The response headers.
        &#34;&#34;&#34;
        self.status: int = status
        self.body: str = json.dumps(body) if isinstance(body, dict) else body
        self.headers: Dict[str, Sequence[str]] = {}
        if headers is not None:
            for name, value in headers.items():
                if value is None:
                    continue
                if isinstance(value, list):
                    self.headers[name.lower()] = value
                elif isinstance(value, set):
                    self.headers[name.lower()] = list(value)
                else:
                    self.headers[name.lower()] = [str(value)]

        if &#34;content-type&#34; not in self.headers.keys():
            if self.body and self.body.startswith(&#34;{&#34;):
                self.headers[&#34;content-type&#34;] = [&#34;application/json;charset=utf-8&#34;]
            else:
                self.headers[&#34;content-type&#34;] = [&#34;text/plain;charset=utf-8&#34;]

    def first_headers(self) -&gt; Dict[str, str]:
        return {k: list(v)[0] for k, v in self.headers.items()}

    def first_headers_without_set_cookie(self) -&gt; Dict[str, str]:
        return {k: list(v)[0] for k, v in self.headers.items() if k != &#34;set-cookie&#34;}

    def cookies(self) -&gt; Sequence[SimpleCookie]:
        header_values = self.headers.get(&#34;set-cookie&#34;, [])
        return [self._to_simple_cookie(v) for v in header_values]

    @staticmethod
    def _to_simple_cookie(header_value: str) -&gt; SimpleCookie:
        c = SimpleCookie()
        c.load(header_value)
        return c</code></pre>
</details>
<div class="desc"><p>The response from a Bolt app.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>HTTP status code</dd>
<dt><strong><code>body</code></strong></dt>
<dd>The response body (dict and str are supported)</dd>
<dt><strong><code>headers</code></strong></dt>
<dd>The response headers.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.BoltResponse.body"><code class="name">var <span class="ident">body</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltResponse.headers"><code class="name">var <span class="ident">headers</span> : Dict[str, Sequence[str]]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.BoltResponse.status"><code class="name">var <span class="ident">status</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.BoltResponse.cookies"><code class="name flex">
<span>def <span class="ident">cookies</span></span>(<span>self) ‑> Sequence[http.cookies.SimpleCookie]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cookies(self) -&gt; Sequence[SimpleCookie]:
    header_values = self.headers.get(&#34;set-cookie&#34;, [])
    return [self._to_simple_cookie(v) for v in header_values]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.BoltResponse.first_headers"><code class="name flex">
<span>def <span class="ident">first_headers</span></span>(<span>self) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_headers(self) -&gt; Dict[str, str]:
    return {k: list(v)[0] for k, v in self.headers.items()}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.BoltResponse.first_headers_without_set_cookie"><code class="name flex">
<span>def <span class="ident">first_headers_without_set_cookie</span></span>(<span>self) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_headers_without_set_cookie(self) -&gt; Dict[str, str]:
    return {k: list(v)[0] for k, v in self.headers.items() if k != &#34;set-cookie&#34;}</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.Complete"><code class="flex name class">
<span>class <span class="ident">Complete</span></span>
<span>(</span><span>client: slack_sdk.web.client.WebClient, function_execution_id: str | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Complete:
    client: WebClient
    function_execution_id: Optional[str]

    def __init__(
        self,
        client: WebClient,
        function_execution_id: Optional[str],
    ):
        self.client = client
        self.function_execution_id = function_execution_id

    def __call__(self, outputs: Optional[Dict[str, Any]] = None) -&gt; SlackResponse:
        &#34;&#34;&#34;Signal the successful completion of the custom function.

        Kwargs:
            outputs: Json serializable object containing the output values

        Returns:
            SlackResponse: The response object returned from slack

        Raises:
            ValueError: If this function cannot be used.
        &#34;&#34;&#34;
        if self.function_execution_id is None:
            raise ValueError(&#34;complete is unsupported here as there is no function_execution_id&#34;)

        return self.client.functions_completeSuccess(function_execution_id=self.function_execution_id, outputs=outputs or {})</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Complete.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Complete.function_execution_id"><code class="name">var <span class="ident">function_execution_id</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.CustomListenerMatcher"><code class="flex name class">
<span>class <span class="ident">CustomListenerMatcher</span></span>
<span>(</span><span>*,<br>app_name: str,<br>func: Callable[..., bool],<br>base_logger: logging.Logger | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomListenerMatcher(ListenerMatcher):
    app_name: str
    func: Callable[..., bool]
    arg_names: MutableSequence[str]
    logger: Logger

    def __init__(self, *, app_name: str, func: Callable[..., bool], base_logger: Optional[Logger] = None):
        self.app_name = app_name
        self.func = func
        self.arg_names = get_arg_names_of_callable(func)
        self.logger = get_bolt_app_logger(self.app_name, self.func, base_logger)

    def matches(self, req: BoltRequest, resp: BoltResponse) -&gt; bool:
        return self.func(
            **build_required_kwargs(
                logger=self.logger,
                required_arg_names=self.arg_names,
                request=req,
                response=resp,
                this_func=self.func,
            )
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.CustomListenerMatcher.app_name"><code class="name">var <span class="ident">app_name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.CustomListenerMatcher.arg_names"><code class="name">var <span class="ident">arg_names</span> : MutableSequence[str]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.CustomListenerMatcher.func"><code class="name">var <span class="ident">func</span> : Callable[..., bool]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.CustomListenerMatcher.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a></b></code>:
<ul class="hlist">
<li><code><a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher.matches" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher.matches">matches</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="slack_bolt.Fail"><code class="flex name class">
<span>class <span class="ident">Fail</span></span>
<span>(</span><span>client: slack_sdk.web.client.WebClient, function_execution_id: str | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fail:
    client: WebClient
    function_execution_id: Optional[str]

    def __init__(
        self,
        client: WebClient,
        function_execution_id: Optional[str],
    ):
        self.client = client
        self.function_execution_id = function_execution_id

    def __call__(self, error: str) -&gt; SlackResponse:
        &#34;&#34;&#34;Signal that the custom function failed to complete.

        Kwargs:
            error: Error message to return to slack

        Returns:
            SlackResponse: The response object returned from slack

        Raises:
            ValueError: If this function cannot be used.
        &#34;&#34;&#34;
        if self.function_execution_id is None:
            raise ValueError(&#34;fail is unsupported here as there is no function_execution_id&#34;)

        return self.client.functions_completeError(function_execution_id=self.function_execution_id, error=error)</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Fail.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Fail.function_execution_id"><code class="name">var <span class="ident">function_execution_id</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.FileAssistantThreadContextStore"><code class="flex name class">
<span>class <span class="ident">FileAssistantThreadContextStore</span></span>
<span>(</span><span>base_dir: str = '/Users/eden.zimbelman/.bolt-app-assistant-thread-contexts')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileAssistantThreadContextStore(AssistantThreadContextStore):

    def __init__(
        self,
        base_dir: str = str(Path.home()) + &#34;/.bolt-app-assistant-thread-contexts&#34;,
    ):
        self.base_dir = base_dir
        self._mkdir(self.base_dir)

    def save(self, *, channel_id: str, thread_ts: str, context: Dict[str, str]) -&gt; None:
        path = f&#34;{self.base_dir}/{channel_id}-{thread_ts}.json&#34;
        with open(path, &#34;w&#34;) as f:
            f.write(json.dumps(context))

    def find(self, *, channel_id: str, thread_ts: str) -&gt; Optional[AssistantThreadContext]:
        path = f&#34;{self.base_dir}/{channel_id}-{thread_ts}.json&#34;
        try:
            with open(path) as f:
                data = json.loads(f.read())
                if data.get(&#34;channel_id&#34;) is not None:
                    return AssistantThreadContext(data)
        except FileNotFoundError:
            pass
        return None

    @staticmethod
    def _mkdir(path: Union[str, Path]):
        if isinstance(path, str):
            path = Path(path)
        path.mkdir(parents=True, exist_ok=True)</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore" href="context/assistant/thread_context_store/store.html#slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore">AssistantThreadContextStore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.FileAssistantThreadContextStore.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *, channel_id: str, thread_ts: str) ‑> <a title="slack_bolt.context.assistant.thread_context.AssistantThreadContext" href="context/assistant/thread_context/index.html#slack_bolt.context.assistant.thread_context.AssistantThreadContext">AssistantThreadContext</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, *, channel_id: str, thread_ts: str) -&gt; Optional[AssistantThreadContext]:
    path = f&#34;{self.base_dir}/{channel_id}-{thread_ts}.json&#34;
    try:
        with open(path) as f:
            data = json.loads(f.read())
            if data.get(&#34;channel_id&#34;) is not None:
                return AssistantThreadContext(data)
    except FileNotFoundError:
        pass
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.FileAssistantThreadContextStore.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, *, channel_id: str, thread_ts: str, context: Dict[str, str]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, *, channel_id: str, thread_ts: str, context: Dict[str, str]) -&gt; None:
    path = f&#34;{self.base_dir}/{channel_id}-{thread_ts}.json&#34;
    with open(path, &#34;w&#34;) as f:
        f.write(json.dumps(context))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.Listener"><code class="flex name class">
<span>class <span class="ident">Listener</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Listener(metaclass=ABCMeta):
    matchers: Sequence[ListenerMatcher]
    middleware: Sequence[Middleware]
    ack_function: Callable[..., BoltResponse]
    lazy_functions: Sequence[Callable[..., None]]
    auto_acknowledgement: bool
    ack_timeout: int = 3

    def matches(
        self,
        *,
        req: BoltRequest,
        resp: BoltResponse,
    ) -&gt; bool:
        is_matched: bool = False
        for matcher in self.matchers:
            is_matched = matcher.matches(req, resp)
            if not is_matched:
                return is_matched
        return is_matched

    def run_middleware(
        self,
        *,
        req: BoltRequest,
        resp: BoltResponse,
    ) -&gt; Tuple[Optional[BoltResponse], bool]:
        &#34;&#34;&#34;Runs a middleware.

        Args:
            req: The incoming request
            resp: The current response

        Returns:
            A tuple of the processed response and a flag indicating termination
        &#34;&#34;&#34;
        for m in self.middleware:
            middleware_state = {&#34;next_called&#34;: False}

            def next_():
                middleware_state[&#34;next_called&#34;] = True

            resp = m.process(req=req, resp=resp, next=next_)  # type: ignore[assignment]
            if not middleware_state[&#34;next_called&#34;]:
                # next() was not called in this middleware
                return (resp, True)
        return (resp, False)

    @abstractmethod
    def run_ack_function(self, *, request: BoltRequest, response: BoltResponse) -&gt; Optional[BoltResponse]:
        &#34;&#34;&#34;Runs all the registered middleware and then run the listener function.

        Args:
            request: The incoming request
            response: The current response

        Returns:
            The processed response
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="slack_bolt.listener.custom_listener.CustomListener" href="listener/custom_listener.html#slack_bolt.listener.custom_listener.CustomListener">CustomListener</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Listener.ack_function"><code class="name">var <span class="ident">ack_function</span> : Callable[..., <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Listener.ack_timeout"><code class="name">var <span class="ident">ack_timeout</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Listener.auto_acknowledgement"><code class="name">var <span class="ident">auto_acknowledgement</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Listener.lazy_functions"><code class="name">var <span class="ident">lazy_functions</span> : Sequence[Callable[..., None]]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Listener.matchers"><code class="name">var <span class="ident">matchers</span> : Sequence[<a title="slack_bolt.listener_matcher.listener_matcher.ListenerMatcher" href="listener_matcher/listener_matcher.html#slack_bolt.listener_matcher.listener_matcher.ListenerMatcher">ListenerMatcher</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Listener.middleware"><code class="name">var <span class="ident">middleware</span> : Sequence[<a title="slack_bolt.middleware.middleware.Middleware" href="middleware/middleware.html#slack_bolt.middleware.middleware.Middleware">Middleware</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_bolt.Listener.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self,<br>*,<br>req: <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a>,<br>resp: <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches(
    self,
    *,
    req: BoltRequest,
    resp: BoltResponse,
) -&gt; bool:
    is_matched: bool = False
    for matcher in self.matchers:
        is_matched = matcher.matches(req, resp)
        if not is_matched:
            return is_matched
    return is_matched</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="slack_bolt.Listener.run_ack_function"><code class="name flex">
<span>def <span class="ident">run_ack_function</span></span>(<span>self,<br>*,<br>request: <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a>,<br>response: <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a>) ‑> <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def run_ack_function(self, *, request: BoltRequest, response: BoltResponse) -&gt; Optional[BoltResponse]:
    &#34;&#34;&#34;Runs all the registered middleware and then run the listener function.

    Args:
        request: The incoming request
        response: The current response

    Returns:
        The processed response
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Runs all the registered middleware and then run the listener function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>The incoming request</dd>
<dt><strong><code>response</code></strong></dt>
<dd>The current response</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The processed response</p></div>
</dd>
<dt id="slack_bolt.Listener.run_middleware"><code class="name flex">
<span>def <span class="ident">run_middleware</span></span>(<span>self,<br>*,<br>req: <a title="slack_bolt.request.request.BoltRequest" href="request/request.html#slack_bolt.request.request.BoltRequest">BoltRequest</a>,<br>resp: <a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a>) ‑> Tuple[<a title="slack_bolt.response.response.BoltResponse" href="response/response.html#slack_bolt.response.response.BoltResponse">BoltResponse</a> | None, bool]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_middleware(
    self,
    *,
    req: BoltRequest,
    resp: BoltResponse,
) -&gt; Tuple[Optional[BoltResponse], bool]:
    &#34;&#34;&#34;Runs a middleware.

    Args:
        req: The incoming request
        resp: The current response

    Returns:
        A tuple of the processed response and a flag indicating termination
    &#34;&#34;&#34;
    for m in self.middleware:
        middleware_state = {&#34;next_called&#34;: False}

        def next_():
            middleware_state[&#34;next_called&#34;] = True

        resp = m.process(req=req, resp=resp, next=next_)  # type: ignore[assignment]
        if not middleware_state[&#34;next_called&#34;]:
            # next() was not called in this middleware
            return (resp, True)
    return (resp, False)</code></pre>
</details>
<div class="desc"><p>Runs a middleware.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong></dt>
<dd>The incoming request</dd>
<dt><strong><code>resp</code></strong></dt>
<dd>The current response</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of the processed response and a flag indicating termination</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.Respond"><code class="flex name class">
<span>class <span class="ident">Respond</span></span>
<span>(</span><span>*,<br>response_url: str | None,<br>proxy: str | None = None,<br>ssl: ssl.SSLContext | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Respond:
    response_url: Optional[str]
    proxy: Optional[str]
    ssl: Optional[SSLContext]

    def __init__(
        self,
        *,
        response_url: Optional[str],
        proxy: Optional[str] = None,
        ssl: Optional[SSLContext] = None,
    ):
        self.response_url = response_url
        self.proxy = proxy
        self.ssl = ssl

    def __call__(
        self,
        text: Union[str, dict] = &#34;&#34;,
        blocks: Optional[Sequence[Union[dict, Block]]] = None,
        attachments: Optional[Sequence[Union[dict, Attachment]]] = None,
        response_type: Optional[str] = None,
        replace_original: Optional[bool] = None,
        delete_original: Optional[bool] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        thread_ts: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -&gt; WebhookResponse:
        if self.response_url is not None:
            client = WebhookClient(
                url=self.response_url,
                proxy=self.proxy,
                ssl=self.ssl,
            )
            text_or_whole_response: Union[str, dict] = text
            if isinstance(text_or_whole_response, str):
                text = text_or_whole_response
                message = _build_message(
                    text=text,
                    blocks=blocks,
                    attachments=attachments,
                    response_type=response_type,
                    replace_original=replace_original,
                    delete_original=delete_original,
                    unfurl_links=unfurl_links,
                    unfurl_media=unfurl_media,
                    thread_ts=thread_ts,
                    metadata=metadata,
                )
                return client.send_dict(message)
            elif isinstance(text_or_whole_response, dict):
                message = _build_message(**text_or_whole_response)
                return client.send_dict(message)
            else:
                raise ValueError(f&#34;The arg is unexpected type ({type(text_or_whole_response)})&#34;)
        else:
            raise ValueError(&#34;respond is unsupported here as there is no response_url&#34;)</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Respond.proxy"><code class="name">var <span class="ident">proxy</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Respond.response_url"><code class="name">var <span class="ident">response_url</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Respond.ssl"><code class="name">var <span class="ident">ssl</span> : ssl.SSLContext | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.SaveThreadContext"><code class="flex name class">
<span>class <span class="ident">SaveThreadContext</span></span>
<span>(</span><span>thread_context_store: <a title="slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore" href="context/assistant/thread_context_store/store.html#slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore">AssistantThreadContextStore</a>,<br>channel_id: str,<br>thread_ts: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SaveThreadContext:
    thread_context_store: AssistantThreadContextStore
    channel_id: str
    thread_ts: str

    def __init__(
        self,
        thread_context_store: AssistantThreadContextStore,
        channel_id: str,
        thread_ts: str,
    ):
        self.thread_context_store = thread_context_store
        self.channel_id = channel_id
        self.thread_ts = thread_ts

    def __call__(self, new_context: Dict[str, str]) -&gt; None:
        self.thread_context_store.save(
            channel_id=self.channel_id,
            thread_ts=self.thread_ts,
            context=new_context,
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.SaveThreadContext.channel_id"><code class="name">var <span class="ident">channel_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SaveThreadContext.thread_context_store"><code class="name">var <span class="ident">thread_context_store</span> : <a title="slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore" href="context/assistant/thread_context_store/store.html#slack_bolt.context.assistant.thread_context_store.store.AssistantThreadContextStore">AssistantThreadContextStore</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SaveThreadContext.thread_ts"><code class="name">var <span class="ident">thread_ts</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.Say"><code class="flex name class">
<span>class <span class="ident">Say</span></span>
<span>(</span><span>client: slack_sdk.web.client.WebClient | None,<br>channel: str | None,<br>thread_ts: str | None = None,<br>metadata: Dict | slack_sdk.models.metadata.Metadata | None = None,<br>build_metadata: Callable[[], Dict | slack_sdk.models.metadata.Metadata | None] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Say:
    client: Optional[WebClient]
    channel: Optional[str]
    thread_ts: Optional[str]
    metadata: Optional[Union[Dict, Metadata]]
    build_metadata: Optional[Callable[[], Optional[Union[Dict, Metadata]]]]

    def __init__(
        self,
        client: Optional[WebClient],
        channel: Optional[str],
        thread_ts: Optional[str] = None,
        metadata: Optional[Union[Dict, Metadata]] = None,
        build_metadata: Optional[Callable[[], Optional[Union[Dict, Metadata]]]] = None,
    ):
        self.client = client
        self.channel = channel
        self.thread_ts = thread_ts
        self.metadata = metadata
        self.build_metadata = build_metadata

    def __call__(
        self,
        text: Union[str, dict] = &#34;&#34;,
        blocks: Optional[Sequence[Union[Dict, Block]]] = None,
        attachments: Optional[Sequence[Union[Dict, Attachment]]] = None,
        channel: Optional[str] = None,
        as_user: Optional[bool] = None,
        thread_ts: Optional[str] = None,
        reply_broadcast: Optional[bool] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        icon_emoji: Optional[str] = None,
        icon_url: Optional[str] = None,
        username: Optional[str] = None,
        markdown_text: Optional[str] = None,
        mrkdwn: Optional[bool] = None,
        link_names: Optional[bool] = None,
        parse: Optional[str] = None,  # none, full
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; SlackResponse:
        if _can_say(self, channel):
            text_or_whole_response: Union[str, dict] = text
            if isinstance(text_or_whole_response, str):
                text = text_or_whole_response
                if metadata is None:
                    metadata = self.build_metadata() if self.build_metadata is not None else self.metadata
                return self.client.chat_postMessage(  # type: ignore[union-attr]
                    channel=channel or self.channel,  # type: ignore[arg-type]
                    text=text,
                    blocks=blocks,
                    attachments=attachments,
                    as_user=as_user,
                    thread_ts=thread_ts or self.thread_ts,
                    reply_broadcast=reply_broadcast,
                    unfurl_links=unfurl_links,
                    unfurl_media=unfurl_media,
                    icon_emoji=icon_emoji,
                    icon_url=icon_url,
                    username=username,
                    markdown_text=markdown_text,
                    mrkdwn=mrkdwn,
                    link_names=link_names,
                    parse=parse,
                    metadata=metadata,
                    **kwargs,
                )
            elif isinstance(text_or_whole_response, dict):
                message: dict = create_copy(text_or_whole_response)
                if &#34;channel&#34; not in message:
                    message[&#34;channel&#34;] = channel or self.channel
                if &#34;thread_ts&#34; not in message:
                    message[&#34;thread_ts&#34;] = thread_ts or self.thread_ts
                if &#34;metadata&#34; not in message:
                    metadata = self.build_metadata() if self.build_metadata is not None else self.metadata
                    message[&#34;metadata&#34;] = metadata
                return self.client.chat_postMessage(**message)  # type: ignore[union-attr]
            else:
                raise ValueError(f&#34;The arg is unexpected type ({type(text_or_whole_response)})&#34;)
        else:
            raise ValueError(&#34;say without channel_id here is unsupported&#34;)</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.Say.build_metadata"><code class="name">var <span class="ident">build_metadata</span> : Callable[[], Dict | slack_sdk.models.metadata.Metadata | None] | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Say.channel"><code class="name">var <span class="ident">channel</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Say.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Say.metadata"><code class="name">var <span class="ident">metadata</span> : Dict | slack_sdk.models.metadata.Metadata | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.Say.thread_ts"><code class="name">var <span class="ident">thread_ts</span> : str | None</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.SetStatus"><code class="flex name class">
<span>class <span class="ident">SetStatus</span></span>
<span>(</span><span>client: slack_sdk.web.client.WebClient, channel_id: str, thread_ts: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetStatus:
    client: WebClient
    channel_id: str
    thread_ts: str

    def __init__(
        self,
        client: WebClient,
        channel_id: str,
        thread_ts: str,
    ):
        self.client = client
        self.channel_id = channel_id
        self.thread_ts = thread_ts

    def __call__(
        self,
        status: str,
        loading_messages: Optional[List[str]] = None,
        **kwargs,
    ) -&gt; SlackResponse:
        return self.client.assistant_threads_setStatus(
            channel_id=self.channel_id,
            thread_ts=self.thread_ts,
            status=status,
            loading_messages=loading_messages,
            **kwargs,
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.SetStatus.channel_id"><code class="name">var <span class="ident">channel_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SetStatus.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SetStatus.thread_ts"><code class="name">var <span class="ident">thread_ts</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.SetSuggestedPrompts"><code class="flex name class">
<span>class <span class="ident">SetSuggestedPrompts</span></span>
<span>(</span><span>client: slack_sdk.web.client.WebClient, channel_id: str, thread_ts: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetSuggestedPrompts:
    client: WebClient
    channel_id: str
    thread_ts: str

    def __init__(
        self,
        client: WebClient,
        channel_id: str,
        thread_ts: str,
    ):
        self.client = client
        self.channel_id = channel_id
        self.thread_ts = thread_ts

    def __call__(
        self,
        prompts: List[Union[str, Dict[str, str]]],
        title: Optional[str] = None,
    ) -&gt; SlackResponse:
        prompts_arg: List[Dict[str, str]] = []
        for prompt in prompts:
            if isinstance(prompt, str):
                prompts_arg.append({&#34;title&#34;: prompt, &#34;message&#34;: prompt})
            else:
                prompts_arg.append(prompt)

        return self.client.assistant_threads_setSuggestedPrompts(
            channel_id=self.channel_id,
            thread_ts=self.thread_ts,
            prompts=prompts_arg,
            title=title,
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.SetSuggestedPrompts.channel_id"><code class="name">var <span class="ident">channel_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SetSuggestedPrompts.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SetSuggestedPrompts.thread_ts"><code class="name">var <span class="ident">thread_ts</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="slack_bolt.SetTitle"><code class="flex name class">
<span>class <span class="ident">SetTitle</span></span>
<span>(</span><span>client: slack_sdk.web.client.WebClient, channel_id: str, thread_ts: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetTitle:
    client: WebClient
    channel_id: str
    thread_ts: str

    def __init__(
        self,
        client: WebClient,
        channel_id: str,
        thread_ts: str,
    ):
        self.client = client
        self.channel_id = channel_id
        self.thread_ts = thread_ts

    def __call__(self, title: str) -&gt; SlackResponse:
        return self.client.assistant_threads_setTitle(
            title=title,
            channel_id=self.channel_id,
            thread_ts=self.thread_ts,
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="slack_bolt.SetTitle.channel_id"><code class="name">var <span class="ident">channel_id</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SetTitle.client"><code class="name">var <span class="ident">client</span> : slack_sdk.web.client.WebClient</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="slack_bolt.SetTitle.thread_ts"><code class="name">var <span class="ident">thread_ts</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="slack_bolt.adapter" href="adapter/index.html">slack_bolt.adapter</a></code></li>
<li><code><a title="slack_bolt.app" href="app/index.html">slack_bolt.app</a></code></li>
<li><code><a title="slack_bolt.async_app" href="async_app.html">slack_bolt.async_app</a></code></li>
<li><code><a title="slack_bolt.authorization" href="authorization/index.html">slack_bolt.authorization</a></code></li>
<li><code><a title="slack_bolt.context" href="context/index.html">slack_bolt.context</a></code></li>
<li><code><a title="slack_bolt.error" href="error/index.html">slack_bolt.error</a></code></li>
<li><code><a title="slack_bolt.kwargs_injection" href="kwargs_injection/index.html">slack_bolt.kwargs_injection</a></code></li>
<li><code><a title="slack_bolt.lazy_listener" href="lazy_listener/index.html">slack_bolt.lazy_listener</a></code></li>
<li><code><a title="slack_bolt.listener" href="listener/index.html">slack_bolt.listener</a></code></li>
<li><code><a title="slack_bolt.listener_matcher" href="listener_matcher/index.html">slack_bolt.listener_matcher</a></code></li>
<li><code><a title="slack_bolt.logger" href="logger/index.html">slack_bolt.logger</a></code></li>
<li><code><a title="slack_bolt.middleware" href="middleware/index.html">slack_bolt.middleware</a></code></li>
<li><code><a title="slack_bolt.oauth" href="oauth/index.html">slack_bolt.oauth</a></code></li>
<li><code><a title="slack_bolt.request" href="request/index.html">slack_bolt.request</a></code></li>
<li><code><a title="slack_bolt.response" href="response/index.html">slack_bolt.response</a></code></li>
<li><code><a title="slack_bolt.util" href="util/index.html">slack_bolt.util</a></code></li>
<li><code><a title="slack_bolt.version" href="version.html">slack_bolt.version</a></code></li>
<li><code><a title="slack_bolt.workflows" href="workflows/index.html">slack_bolt.workflows</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_bolt.Ack" href="#slack_bolt.Ack">Ack</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Ack.response" href="#slack_bolt.Ack.response">response</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.App" href="#slack_bolt.App">App</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.App.action" href="#slack_bolt.App.action">action</a></code></li>
<li><code><a title="slack_bolt.App.assistant" href="#slack_bolt.App.assistant">assistant</a></code></li>
<li><code><a title="slack_bolt.App.attachment_action" href="#slack_bolt.App.attachment_action">attachment_action</a></code></li>
<li><code><a title="slack_bolt.App.block_action" href="#slack_bolt.App.block_action">block_action</a></code></li>
<li><code><a title="slack_bolt.App.block_suggestion" href="#slack_bolt.App.block_suggestion">block_suggestion</a></code></li>
<li><code><a title="slack_bolt.App.client" href="#slack_bolt.App.client">client</a></code></li>
<li><code><a title="slack_bolt.App.command" href="#slack_bolt.App.command">command</a></code></li>
<li><code><a title="slack_bolt.App.default_app_uninstalled_event_listener" href="#slack_bolt.App.default_app_uninstalled_event_listener">default_app_uninstalled_event_listener</a></code></li>
<li><code><a title="slack_bolt.App.default_tokens_revoked_event_listener" href="#slack_bolt.App.default_tokens_revoked_event_listener">default_tokens_revoked_event_listener</a></code></li>
<li><code><a title="slack_bolt.App.dialog_cancellation" href="#slack_bolt.App.dialog_cancellation">dialog_cancellation</a></code></li>
<li><code><a title="slack_bolt.App.dialog_submission" href="#slack_bolt.App.dialog_submission">dialog_submission</a></code></li>
<li><code><a title="slack_bolt.App.dialog_suggestion" href="#slack_bolt.App.dialog_suggestion">dialog_suggestion</a></code></li>
<li><code><a title="slack_bolt.App.dispatch" href="#slack_bolt.App.dispatch">dispatch</a></code></li>
<li><code><a title="slack_bolt.App.enable_token_revocation_listeners" href="#slack_bolt.App.enable_token_revocation_listeners">enable_token_revocation_listeners</a></code></li>
<li><code><a title="slack_bolt.App.error" href="#slack_bolt.App.error">error</a></code></li>
<li><code><a title="slack_bolt.App.event" href="#slack_bolt.App.event">event</a></code></li>
<li><code><a title="slack_bolt.App.function" href="#slack_bolt.App.function">function</a></code></li>
<li><code><a title="slack_bolt.App.global_shortcut" href="#slack_bolt.App.global_shortcut">global_shortcut</a></code></li>
<li><code><a title="slack_bolt.App.installation_store" href="#slack_bolt.App.installation_store">installation_store</a></code></li>
<li><code><a title="slack_bolt.App.listener_runner" href="#slack_bolt.App.listener_runner">listener_runner</a></code></li>
<li><code><a title="slack_bolt.App.logger" href="#slack_bolt.App.logger">logger</a></code></li>
<li><code><a title="slack_bolt.App.message" href="#slack_bolt.App.message">message</a></code></li>
<li><code><a title="slack_bolt.App.message_shortcut" href="#slack_bolt.App.message_shortcut">message_shortcut</a></code></li>
<li><code><a title="slack_bolt.App.middleware" href="#slack_bolt.App.middleware">middleware</a></code></li>
<li><code><a title="slack_bolt.App.name" href="#slack_bolt.App.name">name</a></code></li>
<li><code><a title="slack_bolt.App.oauth_flow" href="#slack_bolt.App.oauth_flow">oauth_flow</a></code></li>
<li><code><a title="slack_bolt.App.options" href="#slack_bolt.App.options">options</a></code></li>
<li><code><a title="slack_bolt.App.process_before_response" href="#slack_bolt.App.process_before_response">process_before_response</a></code></li>
<li><code><a title="slack_bolt.App.shortcut" href="#slack_bolt.App.shortcut">shortcut</a></code></li>
<li><code><a title="slack_bolt.App.start" href="#slack_bolt.App.start">start</a></code></li>
<li><code><a title="slack_bolt.App.step" href="#slack_bolt.App.step">step</a></code></li>
<li><code><a title="slack_bolt.App.use" href="#slack_bolt.App.use">use</a></code></li>
<li><code><a title="slack_bolt.App.view" href="#slack_bolt.App.view">view</a></code></li>
<li><code><a title="slack_bolt.App.view_closed" href="#slack_bolt.App.view_closed">view_closed</a></code></li>
<li><code><a title="slack_bolt.App.view_submission" href="#slack_bolt.App.view_submission">view_submission</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Args" href="#slack_bolt.Args">Args</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Args.ack" href="#slack_bolt.Args.ack">ack</a></code></li>
<li><code><a title="slack_bolt.Args.action" href="#slack_bolt.Args.action">action</a></code></li>
<li><code><a title="slack_bolt.Args.body" href="#slack_bolt.Args.body">body</a></code></li>
<li><code><a title="slack_bolt.Args.client" href="#slack_bolt.Args.client">client</a></code></li>
<li><code><a title="slack_bolt.Args.command" href="#slack_bolt.Args.command">command</a></code></li>
<li><code><a title="slack_bolt.Args.complete" href="#slack_bolt.Args.complete">complete</a></code></li>
<li><code><a title="slack_bolt.Args.context" href="#slack_bolt.Args.context">context</a></code></li>
<li><code><a title="slack_bolt.Args.event" href="#slack_bolt.Args.event">event</a></code></li>
<li><code><a title="slack_bolt.Args.fail" href="#slack_bolt.Args.fail">fail</a></code></li>
<li><code><a title="slack_bolt.Args.get_thread_context" href="#slack_bolt.Args.get_thread_context">get_thread_context</a></code></li>
<li><code><a title="slack_bolt.Args.logger" href="#slack_bolt.Args.logger">logger</a></code></li>
<li><code><a title="slack_bolt.Args.message" href="#slack_bolt.Args.message">message</a></code></li>
<li><code><a title="slack_bolt.Args.next" href="#slack_bolt.Args.next">next</a></code></li>
<li><code><a title="slack_bolt.Args.next_" href="#slack_bolt.Args.next_">next_</a></code></li>
<li><code><a title="slack_bolt.Args.options" href="#slack_bolt.Args.options">options</a></code></li>
<li><code><a title="slack_bolt.Args.payload" href="#slack_bolt.Args.payload">payload</a></code></li>
<li><code><a title="slack_bolt.Args.req" href="#slack_bolt.Args.req">req</a></code></li>
<li><code><a title="slack_bolt.Args.request" href="#slack_bolt.Args.request">request</a></code></li>
<li><code><a title="slack_bolt.Args.resp" href="#slack_bolt.Args.resp">resp</a></code></li>
<li><code><a title="slack_bolt.Args.respond" href="#slack_bolt.Args.respond">respond</a></code></li>
<li><code><a title="slack_bolt.Args.response" href="#slack_bolt.Args.response">response</a></code></li>
<li><code><a title="slack_bolt.Args.save_thread_context" href="#slack_bolt.Args.save_thread_context">save_thread_context</a></code></li>
<li><code><a title="slack_bolt.Args.say" href="#slack_bolt.Args.say">say</a></code></li>
<li><code><a title="slack_bolt.Args.set_status" href="#slack_bolt.Args.set_status">set_status</a></code></li>
<li><code><a title="slack_bolt.Args.set_suggested_prompts" href="#slack_bolt.Args.set_suggested_prompts">set_suggested_prompts</a></code></li>
<li><code><a title="slack_bolt.Args.set_title" href="#slack_bolt.Args.set_title">set_title</a></code></li>
<li><code><a title="slack_bolt.Args.shortcut" href="#slack_bolt.Args.shortcut">shortcut</a></code></li>
<li><code><a title="slack_bolt.Args.view" href="#slack_bolt.Args.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Assistant" href="#slack_bolt.Assistant">Assistant</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Assistant.base_logger" href="#slack_bolt.Assistant.base_logger">base_logger</a></code></li>
<li><code><a title="slack_bolt.Assistant.bot_message" href="#slack_bolt.Assistant.bot_message">bot_message</a></code></li>
<li><code><a title="slack_bolt.Assistant.build_listener" href="#slack_bolt.Assistant.build_listener">build_listener</a></code></li>
<li><code><a title="slack_bolt.Assistant.default_thread_context_changed" href="#slack_bolt.Assistant.default_thread_context_changed">default_thread_context_changed</a></code></li>
<li><code><a title="slack_bolt.Assistant.thread_context_changed" href="#slack_bolt.Assistant.thread_context_changed">thread_context_changed</a></code></li>
<li><code><a title="slack_bolt.Assistant.thread_context_store" href="#slack_bolt.Assistant.thread_context_store">thread_context_store</a></code></li>
<li><code><a title="slack_bolt.Assistant.thread_started" href="#slack_bolt.Assistant.thread_started">thread_started</a></code></li>
<li><code><a title="slack_bolt.Assistant.user_message" href="#slack_bolt.Assistant.user_message">user_message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.AssistantThreadContext" href="#slack_bolt.AssistantThreadContext">AssistantThreadContext</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.AssistantThreadContext.channel_id" href="#slack_bolt.AssistantThreadContext.channel_id">channel_id</a></code></li>
<li><code><a title="slack_bolt.AssistantThreadContext.enterprise_id" href="#slack_bolt.AssistantThreadContext.enterprise_id">enterprise_id</a></code></li>
<li><code><a title="slack_bolt.AssistantThreadContext.team_id" href="#slack_bolt.AssistantThreadContext.team_id">team_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.AssistantThreadContextStore" href="#slack_bolt.AssistantThreadContextStore">AssistantThreadContextStore</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.AssistantThreadContextStore.find" href="#slack_bolt.AssistantThreadContextStore.find">find</a></code></li>
<li><code><a title="slack_bolt.AssistantThreadContextStore.save" href="#slack_bolt.AssistantThreadContextStore.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.BoltContext" href="#slack_bolt.BoltContext">BoltContext</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.BoltContext.ack" href="#slack_bolt.BoltContext.ack">ack</a></code></li>
<li><code><a title="slack_bolt.BoltContext.client" href="#slack_bolt.BoltContext.client">client</a></code></li>
<li><code><a title="slack_bolt.BoltContext.complete" href="#slack_bolt.BoltContext.complete">complete</a></code></li>
<li><code><a title="slack_bolt.BoltContext.fail" href="#slack_bolt.BoltContext.fail">fail</a></code></li>
<li><code><a title="slack_bolt.BoltContext.get_thread_context" href="#slack_bolt.BoltContext.get_thread_context">get_thread_context</a></code></li>
<li><code><a title="slack_bolt.BoltContext.listener_runner" href="#slack_bolt.BoltContext.listener_runner">listener_runner</a></code></li>
<li><code><a title="slack_bolt.BoltContext.respond" href="#slack_bolt.BoltContext.respond">respond</a></code></li>
<li><code><a title="slack_bolt.BoltContext.save_thread_context" href="#slack_bolt.BoltContext.save_thread_context">save_thread_context</a></code></li>
<li><code><a title="slack_bolt.BoltContext.say" href="#slack_bolt.BoltContext.say">say</a></code></li>
<li><code><a title="slack_bolt.BoltContext.set_status" href="#slack_bolt.BoltContext.set_status">set_status</a></code></li>
<li><code><a title="slack_bolt.BoltContext.set_suggested_prompts" href="#slack_bolt.BoltContext.set_suggested_prompts">set_suggested_prompts</a></code></li>
<li><code><a title="slack_bolt.BoltContext.set_title" href="#slack_bolt.BoltContext.set_title">set_title</a></code></li>
<li><code><a title="slack_bolt.BoltContext.to_copyable" href="#slack_bolt.BoltContext.to_copyable">to_copyable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.BoltRequest" href="#slack_bolt.BoltRequest">BoltRequest</a></code></h4>
<ul class="two-column">
<li><code><a title="slack_bolt.BoltRequest.body" href="#slack_bolt.BoltRequest.body">body</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.content_type" href="#slack_bolt.BoltRequest.content_type">content_type</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.context" href="#slack_bolt.BoltRequest.context">context</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.headers" href="#slack_bolt.BoltRequest.headers">headers</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.lazy_function_name" href="#slack_bolt.BoltRequest.lazy_function_name">lazy_function_name</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.lazy_only" href="#slack_bolt.BoltRequest.lazy_only">lazy_only</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.mode" href="#slack_bolt.BoltRequest.mode">mode</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.query" href="#slack_bolt.BoltRequest.query">query</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.raw_body" href="#slack_bolt.BoltRequest.raw_body">raw_body</a></code></li>
<li><code><a title="slack_bolt.BoltRequest.to_copyable" href="#slack_bolt.BoltRequest.to_copyable">to_copyable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.BoltResponse" href="#slack_bolt.BoltResponse">BoltResponse</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.BoltResponse.body" href="#slack_bolt.BoltResponse.body">body</a></code></li>
<li><code><a title="slack_bolt.BoltResponse.cookies" href="#slack_bolt.BoltResponse.cookies">cookies</a></code></li>
<li><code><a title="slack_bolt.BoltResponse.first_headers" href="#slack_bolt.BoltResponse.first_headers">first_headers</a></code></li>
<li><code><a title="slack_bolt.BoltResponse.first_headers_without_set_cookie" href="#slack_bolt.BoltResponse.first_headers_without_set_cookie">first_headers_without_set_cookie</a></code></li>
<li><code><a title="slack_bolt.BoltResponse.headers" href="#slack_bolt.BoltResponse.headers">headers</a></code></li>
<li><code><a title="slack_bolt.BoltResponse.status" href="#slack_bolt.BoltResponse.status">status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Complete" href="#slack_bolt.Complete">Complete</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Complete.client" href="#slack_bolt.Complete.client">client</a></code></li>
<li><code><a title="slack_bolt.Complete.function_execution_id" href="#slack_bolt.Complete.function_execution_id">function_execution_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.CustomListenerMatcher" href="#slack_bolt.CustomListenerMatcher">CustomListenerMatcher</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.CustomListenerMatcher.app_name" href="#slack_bolt.CustomListenerMatcher.app_name">app_name</a></code></li>
<li><code><a title="slack_bolt.CustomListenerMatcher.arg_names" href="#slack_bolt.CustomListenerMatcher.arg_names">arg_names</a></code></li>
<li><code><a title="slack_bolt.CustomListenerMatcher.func" href="#slack_bolt.CustomListenerMatcher.func">func</a></code></li>
<li><code><a title="slack_bolt.CustomListenerMatcher.logger" href="#slack_bolt.CustomListenerMatcher.logger">logger</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Fail" href="#slack_bolt.Fail">Fail</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Fail.client" href="#slack_bolt.Fail.client">client</a></code></li>
<li><code><a title="slack_bolt.Fail.function_execution_id" href="#slack_bolt.Fail.function_execution_id">function_execution_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.FileAssistantThreadContextStore" href="#slack_bolt.FileAssistantThreadContextStore">FileAssistantThreadContextStore</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.FileAssistantThreadContextStore.find" href="#slack_bolt.FileAssistantThreadContextStore.find">find</a></code></li>
<li><code><a title="slack_bolt.FileAssistantThreadContextStore.save" href="#slack_bolt.FileAssistantThreadContextStore.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Listener" href="#slack_bolt.Listener">Listener</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Listener.ack_function" href="#slack_bolt.Listener.ack_function">ack_function</a></code></li>
<li><code><a title="slack_bolt.Listener.ack_timeout" href="#slack_bolt.Listener.ack_timeout">ack_timeout</a></code></li>
<li><code><a title="slack_bolt.Listener.auto_acknowledgement" href="#slack_bolt.Listener.auto_acknowledgement">auto_acknowledgement</a></code></li>
<li><code><a title="slack_bolt.Listener.lazy_functions" href="#slack_bolt.Listener.lazy_functions">lazy_functions</a></code></li>
<li><code><a title="slack_bolt.Listener.matchers" href="#slack_bolt.Listener.matchers">matchers</a></code></li>
<li><code><a title="slack_bolt.Listener.matches" href="#slack_bolt.Listener.matches">matches</a></code></li>
<li><code><a title="slack_bolt.Listener.middleware" href="#slack_bolt.Listener.middleware">middleware</a></code></li>
<li><code><a title="slack_bolt.Listener.run_ack_function" href="#slack_bolt.Listener.run_ack_function">run_ack_function</a></code></li>
<li><code><a title="slack_bolt.Listener.run_middleware" href="#slack_bolt.Listener.run_middleware">run_middleware</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Respond" href="#slack_bolt.Respond">Respond</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Respond.proxy" href="#slack_bolt.Respond.proxy">proxy</a></code></li>
<li><code><a title="slack_bolt.Respond.response_url" href="#slack_bolt.Respond.response_url">response_url</a></code></li>
<li><code><a title="slack_bolt.Respond.ssl" href="#slack_bolt.Respond.ssl">ssl</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.SaveThreadContext" href="#slack_bolt.SaveThreadContext">SaveThreadContext</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.SaveThreadContext.channel_id" href="#slack_bolt.SaveThreadContext.channel_id">channel_id</a></code></li>
<li><code><a title="slack_bolt.SaveThreadContext.thread_context_store" href="#slack_bolt.SaveThreadContext.thread_context_store">thread_context_store</a></code></li>
<li><code><a title="slack_bolt.SaveThreadContext.thread_ts" href="#slack_bolt.SaveThreadContext.thread_ts">thread_ts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.Say" href="#slack_bolt.Say">Say</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.Say.build_metadata" href="#slack_bolt.Say.build_metadata">build_metadata</a></code></li>
<li><code><a title="slack_bolt.Say.channel" href="#slack_bolt.Say.channel">channel</a></code></li>
<li><code><a title="slack_bolt.Say.client" href="#slack_bolt.Say.client">client</a></code></li>
<li><code><a title="slack_bolt.Say.metadata" href="#slack_bolt.Say.metadata">metadata</a></code></li>
<li><code><a title="slack_bolt.Say.thread_ts" href="#slack_bolt.Say.thread_ts">thread_ts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.SetStatus" href="#slack_bolt.SetStatus">SetStatus</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.SetStatus.channel_id" href="#slack_bolt.SetStatus.channel_id">channel_id</a></code></li>
<li><code><a title="slack_bolt.SetStatus.client" href="#slack_bolt.SetStatus.client">client</a></code></li>
<li><code><a title="slack_bolt.SetStatus.thread_ts" href="#slack_bolt.SetStatus.thread_ts">thread_ts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.SetSuggestedPrompts" href="#slack_bolt.SetSuggestedPrompts">SetSuggestedPrompts</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.SetSuggestedPrompts.channel_id" href="#slack_bolt.SetSuggestedPrompts.channel_id">channel_id</a></code></li>
<li><code><a title="slack_bolt.SetSuggestedPrompts.client" href="#slack_bolt.SetSuggestedPrompts.client">client</a></code></li>
<li><code><a title="slack_bolt.SetSuggestedPrompts.thread_ts" href="#slack_bolt.SetSuggestedPrompts.thread_ts">thread_ts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="slack_bolt.SetTitle" href="#slack_bolt.SetTitle">SetTitle</a></code></h4>
<ul class="">
<li><code><a title="slack_bolt.SetTitle.channel_id" href="#slack_bolt.SetTitle.channel_id">channel_id</a></code></li>
<li><code><a title="slack_bolt.SetTitle.client" href="#slack_bolt.SetTitle.client">client</a></code></li>
<li><code><a title="slack_bolt.SetTitle.thread_ts" href="#slack_bolt.SetTitle.thread_ts">thread_ts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
